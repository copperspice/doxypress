/*************************************************************************
 *
 * Copyright (C) 2014-2016 Barbara Geller & Ansel Sermersheim 
 * Copyright (C) 1997-2014 by Dimitri van Heesch.
 * All rights reserved.    
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation under the terms of the GNU General Public License version 2
 * is hereby granted. No representations are made about the suitability of
 * this software for any purpose. It is provided "as is" without express or
 * implied warranty. See the GNU General Public License for more details.
 *
 * Documents produced by DoxyPress are derivative works derived from the
 * input used in their production; they are not affected by this license.
 *
*************************************************************************/

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define yy_create_buffer tclscannerYY_create_buffer
#define yy_delete_buffer tclscannerYY_delete_buffer
#define yy_flex_debug tclscannerYY_flex_debug
#define yy_init_buffer tclscannerYY_init_buffer
#define yy_flush_buffer tclscannerYY_flush_buffer
#define yy_load_buffer_state tclscannerYY_load_buffer_state
#define yy_switch_to_buffer tclscannerYY_switch_to_buffer
#define yyin tclscannerYYin
#define yyleng tclscannerYYleng
#define yylex tclscannerYYlex
#define yylineno tclscannerYYlineno
#define yyout tclscannerYYout
#define yyrestart tclscannerYYrestart
#define yytext tclscannerYYtext
#define yywrap tclscannerYYwrap
#define yyalloc tclscannerYYalloc
#define yyrealloc tclscannerYYrealloc
#define yyfree tclscannerYYfree

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35

#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

// this must be further up in the file
#include <QString>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>

typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE tclscannerYYrestart(tclscannerYYin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 262144
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

extern int tclscannerYYleng;

extern FILE *tclscannerYYin, *tclscannerYYout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE tclscannerYYlex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-tclscannerYYlineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < tclscannerYYleng; ++yyl )\
                    if ( tclscannerYYtext[yyl] == '\n' )\
                        --tclscannerYYlineno;\
            }while(0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up tclscannerYYtext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up tclscannerYYtext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state {
   FILE *yy_input_file;

   char *yy_ch_buf;		/* input buffer */
   char *yy_buf_pos;		/* current position in input buffer */

   /* Size of input buffer in bytes, not including room for EOB
    * characters.
    */
   yy_size_t yy_buf_size;

   /* Number of characters read into yy_ch_buf, not including EOB
    * characters.
    */
   int yy_n_chars;

   /* Whether we "own" the buffer - i.e., we know we created it,
    * and can realloc() it to grow it, and should free() it to
    * delete it.
    */
   int yy_is_our_buffer;

   /* Whether this is an "interactive" input source; if so, and
    * if we're using stdio for input, then we want to use getc()
    * instead of fread(), to make sure we stop fetching input after
    * each newline.
    */
   int yy_is_interactive;

   /* Whether we're considered to be at the beginning of a line.
    * If so, '^' rules will be active on the next match, otherwise
    * not.
    */
   int yy_at_bol;

   int yy_bs_lineno; /**< The line count. */
   int yy_bs_column; /**< The column count. */

   /* Whether to try to fill the input buffer when we reach the
    * end of it.
    */
   int yy_fill_buffer;

   int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
   /* When an EOF's been seen but there's still some text to process
    * then we mark the buffer as YY_EOF_PENDING, to indicate that we
    * shouldn't try reading from the input source any more.  We might
    * still have a bunch of tokens to match, though, because of
    * possible backing-up.
    *
    * When we actually see the EOF, we change the status to "new"
    * (via tclscannerYYrestart()), so that the user can continue scanning by
    * just pointing tclscannerYYin at a new input file.
    */
#define YY_BUFFER_EOF_PENDING 2

};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE *yy_buffer_stack = 0;  /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when tclscannerYYtext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int tclscannerYYleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow tclscannerYYwrap()'s to do buffer switches
 * instead of setting up a fresh tclscannerYYin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void tclscannerYYrestart (FILE *input_file  );
void tclscannerYY_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE tclscannerYY_create_buffer (FILE *file, int size  );
void tclscannerYY_delete_buffer (YY_BUFFER_STATE b  );
void tclscannerYY_flush_buffer (YY_BUFFER_STATE b  );
void tclscannerYYpush_buffer_state (YY_BUFFER_STATE new_buffer  );
void tclscannerYYpop_buffer_state (void );

static void tclscannerYYensure_buffer_stack (void );
static void tclscannerYY_load_buffer_state (void );
static void tclscannerYY_init_buffer (YY_BUFFER_STATE b, FILE *file  );

#define YY_FLUSH_BUFFER tclscannerYY_flush_buffer(YY_CURRENT_BUFFER )

YY_BUFFER_STATE tclscannerYY_scan_buffer (char *base, yy_size_t size  );
YY_BUFFER_STATE tclscannerYY_scan_string (const QString &yy_str  );
YY_BUFFER_STATE tclscannerYY_scan_bytes (yyconst char *bytes, int len  );

void *tclscannerYYalloc (yy_size_t  );
void *tclscannerYYrealloc (void *, yy_size_t  );
void tclscannerYYfree (void *);

#define yy_new_buffer tclscannerYY_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        tclscannerYYensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            tclscannerYY_create_buffer(tclscannerYYin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        tclscannerYYensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            tclscannerYY_create_buffer(tclscannerYYin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define tclscannerYYwrap(n) 1
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

FILE *tclscannerYYin = (FILE *) 0, *tclscannerYYout = (FILE *) 0;

typedef int yy_state_type;

extern int tclscannerYYlineno;

int tclscannerYYlineno = 1;

extern char *tclscannerYYtext;
#define yytext_ptr tclscannerYYtext

static yy_state_type yy_get_previous_state (void );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
static int yy_get_next_buffer (void );
static void yy_fatal_error (yyconst char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up tclscannerYYtext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	(yytext_ptr) -= (yy_more_len); \
	tclscannerYYleng = (size_t) (yy_cp - (yytext_ptr)); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 55
#define YY_END_OF_BUFFER 56
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info {
   flex_int32_t yy_verify;
   flex_int32_t yy_nxt;
};
static yyconst flex_int16_t yy_accept[179] = {
   0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   5,    5,    0,    0,    0,    0,    0,    0,   26,   26,
   0,    0,   56,   55,    1,    4,    3,    3,    2,    4,
   40,   37,   36,   34,   35,   40,   40,   54,   50,   52,
   53,   49,   48,   51,   46,   54,   47,   44,   45,   15,
   5,   14,   15,   55,   23,   24,   55,   55,   17,   18,
   55,   55,   20,   21,   55,   29,   26,   29,   25,   29,
   55,   31,   32,   55,    3,    0,   37,   36,   34,   35,
   0,    0,    0,    0,   39,    0,   42,   43,   41,    5,
   0,   12,   13,    0,    0,    0,    0,   23,   24,    0,

   22,    0,   17,   18,    0,    0,   20,   21,    0,    0,
   25,   26,    0,    0,   31,   32,    0,   30,   33,    0,
   0,    0,    8,   13,    0,    0,    0,    0,   11,    0,
   0,    0,   28,   25,    0,   38,    0,    6,   13,    0,
   7,    0,    0,    0,    0,   27,    6,    0,    0,    0,
   0,    0,    0,    0,    0,   12,    0,    0,    0,    9,
   9,    0,    0,    0,    0,    0,    0,    0,   16,    0,
   12,    0,   10,   10,    0,    0,   19,    0
} ;

static yyconst flex_int32_t yy_ec[256] = {
   0,
   1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    4,    1,    1,    1,    1,
   1,    5,    1,    6,    7,    1,    1,    1,    1,    1,
   1,    8,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    9,   10,
   1,    1,    1,   11,   12,   13,   14,   15,   16,    1,
   1,    1,   17,    1,    1,    1,   18,   19,   20,    1,
   1,   21,    1,   22,    1,   23,    1,    1,    1,    1,
   24,   25,   26,    1,    1,    1,   27,   28,   29,   30,

   31,    1,    1,    1,   32,    1,    1,    1,   33,   34,
   35,    1,    1,   36,    1,   37,    1,   38,    1,    1,
   1,    1,   39,    1,   40,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1
} ;

static yyconst flex_int32_t yy_meta[41] = {
   0,
   1,    2,    3,    1,    2,    2,    4,    1,    2,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    2,    5,    2,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    2,    2
} ;

static yyconst flex_int16_t yy_base[204] = {
   0,
   0,    0,  126,  112,    0,    8,   32,   70,  108,  147,
   14,   22,   19,   27,   35,   42,   44,   51,   57,   63,
   73,   77,  107,  615,  615,  615,   80,   91,  615,  100,
   615,  116,  615,  615,   99,   96,   89,  615,  615,  615,
   615,  615,  615,  615,  615,    3,  615,  615,  615,  615,
   38,  615,  119,   83,  615,  132,  134,   87,  615,  124,
   151,  136,  615,  139,  157,   88,  161,  615,   84,    4,
   142,  615,  166,  171,  175,   81,    0,  615,  615,  183,
   75,  187,   59,   60,  615,   16,  615,  615,  615,   48,
   194,  615,  198,  200,  223,  259,  206,  615,  210,  213,

   615,  202,  615,  217,  225,  229,  615,  236,  239,    8,
   0,  245,  241,  250,  615,  254,  256,  615,  615,    0,
   261,  264,  615,  268,  273,  287,  291,  297,  615,  299,
   301,  304,  615,  306,  311,  615,  320,  615,  334,  336,
   615,  338,  344,  340,  347,  615,  615,  363,  368,  370,
   353,  379,  383,  386,  397,  213,  394,  399,  414,  615,
   278,  408,  420,  434,  423,  439,  441,  451,  615,  455,
   294,  457,  615,  325,  460,  462,  615,  615,  493,  498,
   503,  508,  513,  518,  523,  528,  533,  538,  543,  547,
   549,  554,  559,  564,  569,  574,  579,  584,  589,  594,

   599,  604,  609
} ;

static yyconst flex_int16_t yy_def[204] = {
   0,
   179,  179,  180,  180,  181,  181,  182,  182,  183,  183,
   184,  184,  185,  185,  186,  186,  187,  187,  188,  188,
   189,  189,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  190,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  191,  178,  178,  178,  178,
   178,  178,  192,  193,  178,  193,  193,  194,  178,  194,
   194,  195,  178,  195,  195,  196,  196,  178,  196,  196,
   197,  178,  197,  197,  178,  178,   32,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   192,  178,  192,  198,  192,  192,  193,  178,  193,  193,

   178,  194,  178,  194,  194,  195,  178,  195,  195,  196,
   196,  196,  199,  197,  178,  197,  197,  178,  178,  200,
   192,  198,  178,  198,  201,  198,  192,  192,  178,  194,
   195,  199,  178,  199,  199,  178,  201,  178,  201,  201,
   178,  192,  192,  194,  195,  178,  178,  192,  192,  194,
   195,  192,  192,  194,  195,  202,  192,  194,  195,  178,
   202,  192,  194,  195,  192,  194,  195,  192,  178,  195,
   203,  195,  178,  203,  195,  195,  178,    0,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,

   178,  178,  178
} ;

static yyconst flex_int16_t yy_nxt[656] = {
   0,
   178,   27,   28,  111,   27,   88,   29,  111,   27,   27,
   28,  111,   27,  113,   29,   51,   27,   52,   51,  178,
   53,   55,   56,   51,   30,   52,   51,   89,   53,   55,
   56,  178,   30,   32,   33,   34,   32,   59,   60,   90,
   35,   61,   90,   57,   59,   60,   63,   64,   61,   90,
   65,   57,   90,   63,   64,  120,   36,   65,   67,   68,
   69,   67,   82,   70,   67,   68,   69,   67,  119,   70,
   37,   32,   33,   34,   32,   72,   73,   77,   35,   72,
   73,   75,   75,   75,   75,   98,   99,  111,   75,  103,
   104,  111,   75,   75,   36,   75,   86,   74,   77,   75,

   82,   74,   75,   82,   76,   83,  178,  100,   37,   39,
   40,   41,   42,   43,   24,   76,   44,   77,   78,   79,
   77,   92,   93,   84,   80,   94,  103,  104,   24,   95,
   178,   45,   46,   47,   98,   99,  101,   99,  107,  108,
   81,  107,  108,   96,  115,  116,   48,   49,   39,   40,
   41,   42,   43,  103,  104,   44,  100,  178,  100,  107,
   108,  105,  112,  178,  111,  112,  117,  109,  115,  116,
   45,   46,   47,  118,  116,  105,   75,   75,  178,   75,
   178,  109,  178,   75,   82,   48,   49,   82,   82,   83,
   117,   82,  178,   83,  178,  117,   92,   93,  178,   76,

   92,   93,  123,  124,  103,  104,  125,   84,   98,   99,
   178,   84,   98,   99,  161,  101,   99,  161,  121,  103,
   104,  178,  121,  178,  126,   92,   93,  103,  104,  178,
   100,  107,  108,  178,  100,  178,  127,  100,  107,  108,
   130,  107,  108,  133,  134,  128,  112,  121,  111,  112,
   178,  127,  115,  116,  131,  130,  115,  116,  118,  116,
   128,  129,   93,  129,   93,  135,  123,  124,  178,  131,
   123,  124,  127,  178,  117,  138,  139,  178,  117,  161,
   117,  128,  161,  121,  178,  121,  178,  127,  126,  141,
   124,  178,  126,   92,   93,  174,  128,  140,  174,   92,

   93,  103,  104,  107,  108,  178,  133,  134,  133,  134,
   142,  126,  143,  146,  134,  121,  178,  144,  178,  145,
   178,  121,  138,  139,  178,  142,  174,  143,  135,  174,
   135,  178,  144,  178,  145,  135,  138,  139,  147,  139,
   92,   93,  103,  104,  140,  178,   92,   93,  178,  107,
   108,  178,  148,  178,  150,  107,  108,  178,  140,  178,
   140,  151,  121,  178,  149,   92,   93,  148,  121,  150,
   92,   93,  103,  104,  178,  155,  151,  178,  152,  149,
   153,  156,   93,  154,  178,   92,   93,  121,  103,  104,
   155,  178,  121,  152,  157,  153,   92,   93,  154,  107,

   108,  103,  104,  121,  178,  158,  178,  121,  178,  157,
   92,   93,  159,  163,  178,  162,  107,  108,  121,  178,
   158,  178,  103,  104,  165,   92,   93,  159,  163,  178,
   162,  178,  121,  178,  164,  166,  107,  108,  178,  165,
   168,  169,  104,  107,  108,  178,  167,  121,  178,  164,
   166,  178,  170,  171,   93,  168,  178,  107,  108,  107,
   108,  167,  107,  108,  177,  108,  178,  170,  178,  178,
   178,  178,  178,  175,  178,  121,  172,  176,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  175,  178,
   178,  172,  176,   24,   24,   24,   24,   24,   25,   25,

   25,   25,   25,   26,   26,   26,   26,   26,   31,   31,
   31,   31,   31,   38,   38,   38,   38,   38,   50,   50,
   50,   50,   50,   54,   54,   54,   54,   54,   58,   58,
   58,   58,   58,   62,   62,   62,   62,   62,   66,   66,
   66,   66,   66,   71,   71,   71,   71,   71,   85,   85,
   87,   87,  178,   87,   91,   91,   91,   91,   91,   97,
   97,   97,   97,   97,  102,  102,  102,  102,  102,  106,
   106,  106,  106,  106,  110,  110,  178,  110,  110,  114,
   114,  114,  114,  114,  122,  122,  122,  122,  122,  132,
   132,  132,  132,  132,  136,  136,  178,  136,  136,  137,

   137,  137,  137,  137,  160,  160,  160,  178,  160,  173,
   173,  173,  178,  173,   23,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178
} ;

static yyconst flex_int16_t yy_chk[656] = {
   0,
   0,    5,    5,  111,    5,   46,    5,   70,    5,    6,
   6,  110,    6,   70,    6,   11,    6,   11,   11,    0,
   11,   13,   13,   12,    5,   12,   12,   46,   12,   14,
   14,    0,    6,    7,    7,    7,    7,   15,   15,   51,
   7,   15,   51,   13,   16,   16,   17,   17,   16,   90,
   17,   14,   90,   18,   18,   86,    7,   18,   19,   19,
   19,   19,   84,   19,   20,   20,   20,   20,   83,   20,
   7,    8,    8,    8,    8,   21,   21,   81,    8,   22,
   22,   27,   27,   76,   27,   54,   54,   69,   27,   58,
   58,   66,   28,   28,    8,   28,   37,   21,   36,   28,

   35,   22,   30,   35,   27,   35,   23,   54,    8,    9,
   9,    9,    9,    9,    4,   28,    9,   32,   32,   32,
   32,   53,   53,   35,   32,   53,   60,   60,    3,   53,
   0,    9,    9,    9,   56,   56,   57,   57,   62,   62,
   32,   64,   64,   53,   71,   71,    9,    9,   10,   10,
   10,   10,   10,   61,   61,   10,   56,    0,   57,   65,
   65,   61,   67,    0,   67,   67,   71,   65,   73,   73,
   10,   10,   10,   74,   74,   61,   75,   75,    0,   75,
   0,   65,    0,   75,   80,   10,   10,   80,   82,   80,
   73,   82,    0,   82,    0,   74,   91,   91,    0,   75,

   93,   93,   94,   94,  102,  102,   94,   80,   97,   97,
   0,   82,   99,   99,  156,  100,  100,  156,   91,  104,
   104,    0,   93,    0,   94,   95,   95,  105,  105,    0,
   97,  106,  106,    0,   99,    0,   95,  100,  108,  108,
   105,  109,  109,  113,  113,   95,  112,   95,  112,  112,
   0,   95,  114,  114,  109,  105,  116,  116,  117,  117,
   95,   96,   96,  121,  121,  113,  122,  122,    0,  109,
   124,  124,   96,    0,  114,  125,  125,    0,  116,  161,
   117,   96,  161,   96,    0,  121,    0,   96,  122,  126,
   126,    0,  124,  127,  127,  171,   96,  125,  171,  128,

   128,  130,  130,  131,  131,    0,  132,  132,  134,  134,
   127,  126,  128,  135,  135,  127,    0,  130,    0,  131,
   0,  128,  137,  137,    0,  127,  174,  128,  132,  174,
   134,    0,  130,    0,  131,  135,  139,  139,  140,  140,
   142,  142,  144,  144,  137,    0,  143,  143,    0,  145,
   145,    0,  142,    0,  144,  151,  151,    0,  139,    0,
   140,  145,  142,    0,  143,  148,  148,  142,  143,  144,
   149,  149,  150,  150,    0,  151,  145,    0,  148,  143,
   149,  152,  152,  150,    0,  153,  153,  148,  154,  154,
   151,    0,  149,  148,  153,  149,  157,  157,  150,  155,

   155,  158,  158,  152,    0,  154,    0,  153,    0,  153,
   162,  162,  155,  158,    0,  157,  159,  159,  157,    0,
   154,    0,  163,  163,  162,  165,  165,  155,  158,    0,
   157,    0,  162,    0,  159,  163,  164,  164,    0,  162,
   165,  166,  166,  167,  167,    0,  164,  165,    0,  159,
   163,    0,  167,  168,  168,  165,    0,  170,  170,  172,
   172,  164,  175,  175,  176,  176,    0,  167,    0,    0,
   0,    0,    0,  172,    0,  168,  170,  175,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,  172,    0,
   0,  170,  175,  179,  179,  179,  179,  179,  180,  180,

   180,  180,  180,  181,  181,  181,  181,  181,  182,  182,
   182,  182,  182,  183,  183,  183,  183,  183,  184,  184,
   184,  184,  184,  185,  185,  185,  185,  185,  186,  186,
   186,  186,  186,  187,  187,  187,  187,  187,  188,  188,
   188,  188,  188,  189,  189,  189,  189,  189,  190,  190,
   191,  191,    0,  191,  192,  192,  192,  192,  192,  193,
   193,  193,  193,  193,  194,  194,  194,  194,  194,  195,
   195,  195,  195,  195,  196,  196,    0,  196,  196,  197,
   197,  197,  197,  197,  198,  198,  198,  198,  198,  199,
   199,  199,  199,  199,  200,  200,    0,  200,  200,  201,

   201,  201,  201,  201,  202,  202,  202,    0,  202,  203,
   203,  203,    0,  203,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
   178,  178,  178,  178,  178
} ;

/* Table of booleans, true if rule could match eol. */
static yyconst flex_int32_t yy_rule_can_match_eol[56] = {
   0,
   0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1,
   1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0,
   0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int tclscannerYY_flex_debug;
int tclscannerYY_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
static int yy_more_flag = 0;
static int yy_more_len = 0;
#define yymore() ((yy_more_flag) = 1)
#define YY_MORE_ADJ (yy_more_len)
#define YY_RESTORE_YY_MORE_OFFSET
char *tclscannerYYtext;

#include <QFile>
#include <QHash>
#include <QRegExp>
#include <QStringList>
#include <QStack>
#include <QVector>

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <unistd.h>

#include <arguments.h>
#include <commentcnv.h>
#include <commentscan.h>
#include <config.h>
#include <doxy_globals.h>
#include <defargs.h>
#include <entry.h>
#include <language.h>
#include <message.h>
#include <outputlist.h>
#include <parse_tcl.h>
#include <pre.h>
#include <util.h>

#define YY_NEVER_INTERACTIVE 1
#define YY_NO_INPUT 1

#define MAX_INCLUDE_DEPTH 10

//! Application error.
#define tcl_err \
  printf("Error %d %s() at line %d: ",__LINE__, qPrintable(tcl.file_name), tclscannerYYlineno); \
  yy_push_state(ERROR); \
  yyless(0); \
  printf

//! Application warning.
#define tcl_war \
  printf("Warning %d %s() at line %d: ",__LINE__, qPrintable(tcl.file_name), tclscannerYYlineno); \
  printf

//! Application message.
#define tcl_inf \
  if (0) printf("--- %.4d %d@%d: ",__LINE__, tclscannerYYlineno, yy_start_stack_ptr) && printf

// BEGIN of copy from tclUtil.c
// - Tcl_Interp removed
// - changes are marked with RZ
// #define's to adapt the code:

#define CONST           const
#define UCHAR           (unsigned char)
#define TCL_ERROR       1
#define TCL_OK          0
#define ckalloc         malloc
#define ckfree          free

int TclFindElement(const QString &list, int listLength, int &elementIndex, int &nextIndex, int *sizePtr, int *bracePtr) 
{
   const QChar *p = list.constData();
   const QChar *ptr = p;

   const QChar *elemStart;              /* Points to first byte of first element. */
   const QChar *limit;                  /* Points just after list's last byte. */

   int openBraces = 0;                  /* Brace nesting level during parse. */
   int inQuotes   = 0;
   int size       = 0;        
  
   /*
    * Skim off leading white space and check for an opening brace or quote.
    * We treat embedded NULLs in the list as bytes belonging to a list element.
    */

   limit = ptr + listLength;

   while ((p < limit) && ( p->isSpace())) {
      p++;
   }

   if (p == limit) {
      // no element found 
      elemStart = limit;
      goto done;
   }

   if (*p == '{') {
      openBraces = 1;
      p++;

   } else if (*p == '"') {
      inQuotes = 1;
      p++;

   }

   elemStart = p;

   if (bracePtr != 0) {
      *bracePtr = openBraces;
   }
   
   // Find element's end (a space, close brace, or the end of the string 
   while (p < limit) {

      switch (p->unicode()) {
         /*
          * Open brace: do not treat specially unless the element is in
          * braces. In this case, keep a nesting count.
          */

         case '{':
            if (openBraces != 0) {
               openBraces++;
            }
            break;

         /*
          * Close brace: if element is in braces, keep nesting count and
          * quit when the last close brace is seen.
          */

         case '}':
            if (openBraces > 1) {
               openBraces--;

            } else if (openBraces == 1) {
               size = p - elemStart;
               p++;

               if ((p >= limit) || p->isSpace()) {                  
                  goto done;
               }
               
               // Garbage after the closing brace; return an error.               
               return TCL_ERROR;
            }
            break;

          /*
          * Backslash: skip over everything up to the end of the backslash
          * sequence.
          */

         case '\\':           
            p++; //RZ
            break;

          /*
          * Space: ignore if element is in braces or quotes; otherwise
          * terminate element.
          */

         case ' ':
         case '\f':
         case '\n':
         case '\r':
         case '\t':
         case '\v':
            if ((openBraces == 0) && ! inQuotes) {
               size = p - elemStart;
               goto done;
            }
            break;

          /*
          * Double-quote: if element is in quotes then terminate it.
          */

         case '"':
            if (inQuotes) {
               size = (p - elemStart);
               p++;

               if ((p >= limit) || p->isSpace()) {                
                  goto done;
               }

                /*
                * Garbage after the closing quote; return an error.
                */
               return TCL_ERROR;
            }
            break;
      }
      p++;
   }
   
   // End of list: terminate element    
   if (p == limit) {
      if (openBraces != 0) {
         return TCL_ERROR;

      } else if (inQuotes) {
         return TCL_ERROR;

      }

      size = (int)(p - elemStart);
   }

done:
   while ((p < limit) && p->isSpace()) {
      p++;
   }

   elementIndex = elemStart - ptr;
   nextIndex    = p - ptr;

   if (sizePtr != 0) {
      *sizePtr = size;
   }

   return TCL_OK;
}


/* Pointer to string with list structure. */
/* Pointer to location to fill in with the number of elements in the list. */
/* Pointer to place to store pointer to array of pointers to list elements. */

int tcl_split_internal(const QString &str, QStringList &list)           
{ 
   int result;

   int elementIdx;
   int nextIdx;
   int size;
   int brace;
    
   int length;  
   int elSize;
     
   QString data = str;
   length = str.length();
  
   while (! data.isEmpty()) { 

      result  = TclFindElement(data, length, elementIdx, nextIdx, &elSize, &brace);
      length -= nextIdx; 

      if (result != TCL_OK) {         
         return result;
      }

      if (elementIdx == length) {
         break;
      }          
     
      list.append(data.mid(elementIdx, elSize));    

      // remove used data
      data.mid(nextIdx);
   }

   return TCL_OK;
}

QStringList tcl_split_list(QString &str)
{
   QStringList retval;
   
   if (str.left(1) == "{" && str.right(1) == "}") {
      str = str.mid(1, str.length() - 2);

   } else if (str.left(1) == "\"" && str.right(1) == "\"") {
      str = str.mid(1, str.length() - 2);

   }

   if (tcl_split_internal(str, retval) != TCL_OK) {
      retval.append(str); 
   }

   return retval;
}

//! Structure containing information about current scan context.
typedef struct {
   QChar tclType;                       // type of scan context: "\"" "{" "[" "?" " "
   int line0;                           // start line of scan context
   int line1;                           // end line of scan context
   YY_BUFFER_STATE buffer_state;        // value of scan context
   QString ns;                          // current namespace

   QSharedPointer<Entry> entry_fn;      // if set contains the current proc/method/constructor/destructor
   QSharedPointer<Entry> entry_cl;      // if set contain the current class
   QSharedPointer<Entry> entry_scan;    // current scan entry

   Protection protection;               // current protections state
   QStringList after;                   // option/value list (options: NULL comment keyword script)
} tcl_scan;

// Structure containing all internal global variables.
static struct {
   CodeOutputInterface *code;   // if set then we are codifying the file

   int code_line;               // current line of code
   int code_linenumbers;        // if true create line numbers in code
   QString code_font;           // used font to codify
   bool config_autobrief;       // value of configuration option

   QMap<QString, QString> config_subst; // map of configuration option values
   QString input_string;                // file contents
   int input_position;                  // position in file
   QString file_name;                   // name of used file
   ParserInterface *this_parser;        // myself

   int command;          // true if command was found
   int comment;          // set true if comment was scaned
   int brace_level;      // bookkeeping of braces
   int bracket_level;    // bookkeeping of brackets
   int bracket_quote;    // bookkeeping of quotes (toggles)

   QChar word_is;        // type of current word: "\"" "{" "[" "?" " "

   int line_comment;     // line number of comment
   int line_commentline; // line number of comment after command
   int line_command;     // line number of command
   int line_body0;       // start line of body
   int line_body1;       // end line of body

   QString string_command;          // contain current command
   QString string_commentline;      // contain current comment after command
   QString string_commentcodify;    // current comment string used in codifying
   QString string_comment;          // contain current comment
   QString string_last;             // contain last read word or part of word
   QString string;                  // temporary string value

   QSharedPointer<Entry>  entry_main;            // top level entry
   QSharedPointer<Entry>  entry_file;            // entry of current file
   QSharedPointer<Entry>  entry_current;         // currently used entry 
   QSharedPointer<Entry>  entry_inside;          // contain entry of current scan context
                                       
   QStringList listCommandwords;                 // list of command words
   QList<tcl_scan *> listScan;                   // scan contexts

   QMap<QString, QSharedPointer<Entry>> ns;      // all read namespace entries
   QMap<QString, QSharedPointer<Entry>> cl;      // all read class entries
   QMap<QString, QSharedPointer<Entry>> fn;      // all read function entries

   QList<QSharedPointer<Entry>> entry;           // list of all created entries, will be deleted after codifying

   Protection protection;                        // current protections state
   QSharedPointer<MemberDef> memberdef;          // contain current MemberDef when codifying
   bool collectXRefs;
} tcl;

// scanner functions
static int yyread(char *buf, int max_size);
static tcl_scan *tcl_scan_start(QChar type, const QString  &content, const QString &ns, 
                  QSharedPointer<Entry> entry_cls, QSharedPointer<Entry> entry_fn);

static void tcl_scan_end();
static void tcl_comment(int what, const QString  &text);
static void tcl_word(int what, const QString  &text);
static void tcl_command(int what, const QString  &text);

// helper functions

//! Create new entry.
// @return new initialised entry
QSharedPointer<Entry> tcl_entry_new()
{
   QSharedPointer<Entry> myEntry = QMakeShared<Entry>();

   myEntry->section    = Entry::EMPTY_SEC;

   myEntry->name       = "";   
   myEntry->brief      = "";   
   myEntry->protection = Public;   
   myEntry->fileName   = tcl.file_name;
   myEntry->lang       = SrcLangExt_Tcl;

   initGroupInfo(myEntry);

   // collect entries
   if (! tcl.code) {
      tcl.entry.insert(0, myEntry);
   }

   return myEntry;
}

//! Set protection level.
void tcl_protection(QSharedPointer<Entry> entry)
{
   if (entry->protection != Public && entry->protection != Protected && entry->protection != Private) {
      entry->protection = tcl.protection;
   }
   if (entry->protection != Protected && entry->protection != Private) {
      entry->protection = Public;
   }
}

//! Check name.
// @return 'ns' and 'name' of given current 'ns0' and 'name0'
static void tcl_name(const QString &ns0, const QString &name0, QString &ns, QString &name)
{
   QString myNm;
   int myStart;

   if (name0.startsWith("::")) {
      myNm = name0.mid(2);

   } else if (ns0.length() && ns0 != " ") {
      myNm = ns0 + "::" + name0;

   } else {
      myNm = name0;
   }

   myStart = myNm.lastIndexOf("::");

   if (myStart == -1) {
      ns = "";
      name = myNm;

   } else {
      ns = myNm.mid(0, myStart);
      name = myNm.mid(myStart + 2);
   }
}

//! Check name. Strip namespace qualifiers from name0 if inside inlined code segment.
// @return 'ns' and 'name' of given current 'ns0' and 'name0'
static void tcl_name_SnippetAware(const QString &ns0, const QString &name0, QString &ns, QString &name)
{
   // If we are inside an inlined code snippet then ns0
   // already containes the complete namespace path.
   // Any namespace qualifiers in name0 are redundant.
   int i = name0.lastIndexOf("::");

   if (i >= 0 && tcl.memberdef) {
      tcl_name(ns0, name0.mid(i + 2), ns, name);
   } else {
      tcl_name(ns0, name0, ns, name);
   }
}

// Check and return namespace entry.
// @return namespace entry
QSharedPointer<Entry> tcl_entry_namespace(const QString ns)
{
   QSharedPointer<Entry> myEntry;

   if (ns.length()) {
      myEntry = tcl.ns.value(ns);

   } else {
      myEntry = tcl.ns.value("::");
   }

   if (myEntry == NULL) {
      myEntry = tcl_entry_new();

      myEntry->section    = Entry::NAMESPACE_SEC;
      myEntry->name       = ns;

      tcl.entry_main->addSubEntry(myEntry, tcl.entry_main);
      tcl.ns.insert(ns, myEntry);
   }

   return myEntry;
}

// Check and return class entry.
// @return class entry
QSharedPointer<Entry> tcl_entry_class(const QString cl)
{
   QSharedPointer<Entry> myEntry;

   if (! cl.length()) {
      return QSharedPointer<Entry>();
   }

   myEntry = tcl.cl.value(cl);

   if (myEntry == NULL) {
      myEntry = tcl_entry_new();

      myEntry->section    = Entry::CLASS_SEC;
      myEntry->name       = cl;

      tcl.entry_main->addSubEntry(myEntry, tcl.entry_main);
      tcl.cl.insert(cl, myEntry);
   }

   return myEntry;
}

//! Check for keywords.
// @return 1 if keyword and 0 otherwise
static int tcl_keyword(QString str)
{
   static QStringList myList;
   static int myInit = 1;

   if (myInit) {
      // tcl keywords

      myList << "append" << "apply" << "array" << "auto_execok" << "auto_import" << "auto_load" << "auto_mkindex" 
             << "auto_qualify" << "auto_reset";

      myList << "binary";
      myList << "catch" << "cd" << "close" << "clock" << "concat";
      myList << "eof" << "eval" << "exec" << "exit" << "expr";
      myList << "fblocked" << "fconfigure" << "file" << "fileevent" << "flush" << "for" << "foreach" << "format";
      myList << "gets" << "global";
      myList << "http";
      myList << "if" << "incr" << "info" << "interp";
      myList << "join";
      myList << "lappend" << "lassign" << "lindex" << "linsert" << "llength" << "load" << "lrange" << "lrepeat" 
             << "lreplace" << "lreverse" << "lset";

      myList << "namespace";
      myList << "package" << "parray" << "pid" << "pkg_mkIndex" << "proc" << "puts" << "pwd";
      myList << "registry" << "rename" << "return";
      myList << "scan" << "set" << "split" << "string" << "switch";

      myList << "tclLog" << "tcl_endOfWord" << "tcl_findLibrary" << "tcl_startOfNextWord" << "tcl_startOfPreviousWord" 
             << "tcl_wordBreakAfter" << "tcl_wordBreakBefore" << "tell" << "time";

      myList << "unknown" << "upvar";
      myList << "variable" << "vwait";

      // tk keywords
      myList << "bell" << "bind" << "bindtags";
      myList << "clipboard" << "console" << "consoleinterp";
      myList << "destroy";
      myList << "event";
      myList << "focus";
      myList << "grid";
      myList << "lower";
      myList << "option";
      myList << "pack" << "place";
      myList << "raise";
      myList << "send";

      myList << "tkerror" << "tkwait" << "tk_bisque" << "tk_focusNext" << "tk_focusPrev" << "tk_focusFollowsMouse" << "tk_popup" 
             << "tk_setPalette" << "tk_textCut" << "tk_TextCopy" << "tk_textPaste" << "chooseColor" << "tk_chooseColor" 
             << "tk_chooseDirectory" << "tk_dialog" << "tk_getOpenFile" << "tkDialog" << "tk_getSaveFile" << "tk_messageBox";

      myList << "winfo" << "wm";
      myList << "button" << "canvas" << "checkbutton" << "entry" << "frame" << "image" << "label" << "labelframe" 
             << "listbox" << "menu" << "menubutton" << "message" << "panedwindow" << "radiobutton" << "scale" << "scrollbar"
             << "spinbox" << "toplevel";

      myList.sort();
      myInit = 0;
   }

   str = str.trimmed();

   if (str.left(2) == "::") {
      str = str.mid(2);
   }

   if (myList.indexOf(str) != -1) {
      return (1);
   }

   return 0;
}

//! End codifying with special font class.
static void tcl_font_end()
{
   if (! tcl.code) {
      return;
   }

   if (! tcl.code_font.isEmpty()) {
      tcl.code->endFontClass();
      tcl.code_font = "";
   }
}

// Codify 'str' with special font class 's'.
static void tcl_codify(const QString &s, const QString &str)
{
   if (! tcl.code || str.isEmpty() ) {
      return;
   }

   if (s != "NULL") {
      tcl_font_end();
      tcl.code->startFontClass(s);
      tcl.code_font = s;
   }
  
   QString tmp;

   for (auto c : str) {      

      if (c == '\n') {
         tcl.code_line++;
         
         tcl.code->codify(tmp);

         if (! tcl.code_font.isEmpty()) {
            tcl.code->endFontClass();
         }

         tcl.code->endCodeLine();
         tcl.code->startCodeLine(tcl.code_linenumbers);

         if (tcl.code_linenumbers) {
            tcl.code->writeLineNumber(0, 0, 0, tcl.code_line);
         }

         if (! tcl.code_font.isEmpty()) {
            tcl.code->startFontClass(tcl.code_font);
         }

         tmp = "";

      } else {
         tmp += c;
        
      }
   }

   if ( ! tmp.isEmpty() ) {
      tcl.code->codify(tmp);
   }  

   tcl_font_end();
}

static void tcl_codify_cmd(const QString &s, int i)
{
   tcl_codify(s, tcl.listCommandwords.at(i) );
}

//! codify a string token
//
// codifies string according to type.
// Starts a new scan context if needed (myScan == 0 and type == "script").
// Returns NULL or the created scan context.
//
static tcl_scan *tcl_codify_token(tcl_scan *myScan, const QString type, const QString &string)
{
   if (myScan != NULL) {

      if (! type.isEmpty()) {
         myScan->after << type << string;
      } else {
         myScan->after << "NULL" << string;
      }

   } else {
      if (type == "script") {

         if (tcl.listScan.length() > 0) { 
            myScan = tcl.listScan.at(0);
            myScan = tcl_scan_start('?', string, myScan->ns, myScan->entry_cl, myScan->entry_fn);               
         }        

      } else {
         tcl_codify(type, string);
      }
   }

   return myScan;
}

#undef  YY_INPUT
#define YY_INPUT(buf,result,max_size) result=yyread(buf,max_size);

#define INITIAL 0
#define ERROR 1
#define TOP 2
#define COMMAND 3
#define WORD 4
#define COMMENT 5
#define COMMENT_NL 6
#define COMMENT_CODE 7
#define COMMENT_VERB 8
#define COMMENTLINE 9
#define COMMENTLINE_NL 10

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int tclscannerYYlex_destroy (void );

int tclscannerYYget_debug (void );

void tclscannerYYset_debug (int debug_flag  );

YY_EXTRA_TYPE tclscannerYYget_extra (void );

void tclscannerYYset_extra (YY_EXTRA_TYPE user_defined  );

FILE *tclscannerYYget_in (void );

void tclscannerYYset_in  (FILE *in_str  );

FILE *tclscannerYYget_out (void );

void tclscannerYYset_out  (FILE *out_str  );

int tclscannerYYget_leng (void );

char *tclscannerYYget_text (void);

int tclscannerYYget_lineno (void);

void tclscannerYYset_lineno (int line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int tclscannerYYwrap (void );
#else
extern int tclscannerYYwrap (void );
#endif
#endif

static void yyunput (int c, char *buf_ptr);

#ifndef yytext_ptr
static void yy_flex_strncpy (char *, yyconst char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char *);
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void );
#else
static int input (void );
#endif

#endif

static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = NULL;

static void yy_push_state (int new_state );

static void yy_pop_state (void );

static int yy_top_state (void );

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 262144
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( tclscannerYYtext, tclscannerYYleng, 1, tclscannerYYout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( tclscannerYYin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( tclscannerYYin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, tclscannerYYin))==0 && ferror(tclscannerYYin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(tclscannerYYin); \
			} \
		}\
\
 
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int tclscannerYYlex (void);

#define YY_DECL int tclscannerYYlex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after tclscannerYYtext and tclscannerYYleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL {
   register yy_state_type yy_current_state;
   register char *yy_cp, *yy_bp;
   register int yy_act;

   if ( !(yy_init) )
   {
      (yy_init) = 1;

#ifdef YY_USER_INIT
      YY_USER_INIT;
#endif

      if ( ! (yy_start) ) {
         (yy_start) = 1;   /* first start state */
      }

      if ( ! tclscannerYYin ) {
         tclscannerYYin = stdin;
      }

      if ( ! tclscannerYYout ) {
         tclscannerYYout = stdout;
      }

      if ( ! YY_CURRENT_BUFFER ) {
         tclscannerYYensure_buffer_stack ();
         YY_CURRENT_BUFFER_LVALUE = tclscannerYY_create_buffer(tclscannerYYin, YY_BUF_SIZE );
      }

      tclscannerYY_load_buffer_state( );
   }

   while ( 1 )		/* loops until end-of-file is reached */
   {
      (yy_more_len) = 0;
      if ( (yy_more_flag) ) {
         (yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
         (yy_more_flag) = 0;
      }
      yy_cp = (yy_c_buf_p);

      /* Support of tclscannerYYtext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
   yy_match:
      do {
         register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
         if ( yy_accept[yy_current_state] ) {
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
         }
         while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state >= 179 ) {
               yy_c = yy_meta[(unsigned int) yy_c];
            }
         }
         yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
         ++yy_cp;
      } while ( yy_base[yy_current_state] != 615 );

   yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if ( yy_act == 0 ) {
         /* have to back up */
         yy_cp = (yy_last_accepting_cpos);
         yy_current_state = (yy_last_accepting_state);
         yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] ) {
         int yyl;
         for ( yyl = (yy_more_len); yyl < tclscannerYYleng; ++yyl )
            if ( tclscannerYYtext[yyl] == '\n' )

            {
               tclscannerYYlineno++;
            }
         ;
      }

   do_action:	/* This label is used only to access EOF actions. */

      switch ( yy_act ) {
         /* beginning of action switch */
         case 0: /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = (yy_hold_char);
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            goto yy_find_action;

         case 1:
            YY_RULE_SETUP

            {               
               yyterminate();
            }
            YY_BREAK
         case YY_STATE_EOF(INITIAL):
         case YY_STATE_EOF(ERROR):
         case YY_STATE_EOF(TOP):
         case YY_STATE_EOF(COMMAND):
         case YY_STATE_EOF(WORD):
         case YY_STATE_EOF(COMMENT):
         case YY_STATE_EOF(COMMENT_NL):
         case YY_STATE_EOF(COMMENT_CODE):
         case YY_STATE_EOF(COMMENT_VERB):
         case YY_STATE_EOF(COMMENTLINE):
         case YY_STATE_EOF(COMMENTLINE_NL):

         {
            if (tcl.listScan.length() < 1) {
               // error               
               tcl_err("Tcl parser stack empty, parser error in file '%s'.\n", qPrintable(tcl.file_name) );
               yyterminate();

            } else if (tcl.listScan.length() == 1) {
               // exit, check on input?               
               yyterminate();

            } else {
               // continue               
               tcl_command(-1, "");
               tcl_scan_end();
            }
         }
         YY_BREAK
         case 2:
            YY_RULE_SETUP

            {  
               yyless(0);
               tcl.line_comment = tclscannerYYlineno;
               tcl_comment(0, "");
            }
            YY_BREAK
         case 3:
            /* rule 3 can match eol */
            YY_RULE_SETUP

            {       
               QString text = QString::fromUtf8(tclscannerYYtext);         
               tcl_codify(NULL, text);
            }
            YY_BREAK
         case 4:
            YY_RULE_SETUP

            {               
               yyless(0);
               tcl.line_command = tclscannerYYlineno;
               tcl_command(0, "");
            }
            YY_BREAK
         case 5:
            YY_RULE_SETUP

            {               
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
            }
            YY_BREAK
         case 6:
            /* rule 6 can match eol */
            YY_RULE_SETUP

            {               
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               tcl_comment(2, text + 1);
            }
            YY_BREAK
         case 7:
            /* rule 7 can match eol */
            YY_RULE_SETUP

            {               
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               QString t = text;
               t = t.mid(2, t.length() - 3);
               t.append("\n");
               tcl_comment(1, t);
               yy_push_state(COMMENT_NL);
            }
            YY_BREAK
         case 8:
            /* rule 8 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               tcl_comment(1, text.mid(2) );
            }
            YY_BREAK
         case 9:
            /* rule 9 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text.left(7));
               tcl_comment(2, "\n@code\n");
               yyless(7);
               yy_push_state(COMMENT_CODE);
            }
            YY_BREAK
         case 10:
            /* rule 10 can match eol */
            YY_RULE_SETUP

            {              
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text.left(11));
               tcl_comment(2, "\n@verbatim\n");
               yyless(11);
               yy_push_state(COMMENT_VERB);
            }
            YY_BREAK
         case 11:
            /* rule 11 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               text = text.mid(1, text.length() - 3);
               text.append("\n");
               tcl_comment(2, text);
               yy_push_state(COMMENT_NL);
            }
            YY_BREAK
         case 12:
            /* rule 12 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               tcl_comment(2, text.mid(1) );
            }
            YY_BREAK
         case 13:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               text = text.mid(0, text.length() - 1);
               tcl_codify("comment", text);

               text = text.mid(1, text.length());
               tcl_comment(-2, text);
               unput(0x1A);
            }
            YY_BREAK
         case 14:
            YY_RULE_SETUP

            {
               tcl_comment(-2, "");
               unput(0x1A);
            }
            YY_BREAK
         case 15:
            /* rule 15 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_comment(-2, text);
               yyless(0);
            }
            YY_BREAK
         case 16:
            /* rule 16 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               text = text.left(text.length() - 10);
               tcl_comment(2, text);
               tcl_comment(2, "\n@endcode\n");
               yy_pop_state();
               yyless(0);
            }
            YY_BREAK
         case 17:
            /* rule 17 can match eol */
            YY_RULE_SETUP

            {               
               yymore();
            }
            YY_BREAK
         case 18:
            YY_RULE_SETUP

            {
               yy_pop_state();
               yyless(0);
            }
            YY_BREAK
         case 19:
            /* rule 19 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               text = text.left(text.length() - 14);
               tcl_comment(2, text);
               tcl_comment(2, "\n@endverbatim\n");
               yy_pop_state();
               yyless(0);
            }
            YY_BREAK
         case 20:
            /* rule 20 can match eol */
            YY_RULE_SETUP

            {
               yymore();
            }
            YY_BREAK
         case 21:
            YY_RULE_SETUP

            {
               yy_pop_state();
               yyless(0);
            }
            YY_BREAK
         case 22:
            /* rule 22 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               tcl_comment(2, text);
            }
            YY_BREAK
         case 23:
            /* rule 23 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_codify("comment", text);
               tcl_comment(2, text);
               yy_pop_state();
            }
            YY_BREAK
         case 24:
            YY_RULE_SETUP

            {
               yy_pop_state();
               yyless(0);
            }
            YY_BREAK
         case 25:
            YY_RULE_SETUP

            {
               yy_pop_state();
               yyless(0);
            }
            YY_BREAK
         case 26:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify += text;
            }
            YY_BREAK
         case 27:
            /* rule 27 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify += text;

               text = text.mid(2, text.length() - 4);
               text.append("\n");
               tcl.string_commentline += text;

               yy_push_state(COMMENTLINE_NL);
            }
            YY_BREAK
         case 28:
            /* rule 28 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify += text;
               tcl.string_commentline += (text + 2);
            }
            YY_BREAK
         case 29:
            /* rule 29 can match eol */
            YY_RULE_SETUP

            {
               yy_pop_state();
               if (tcl.string_commentline.length())
               {
                  tcl.entry_current->brief = tcl.string_commentline;
                  tcl.entry_current->briefLine = tcl.line_commentline;
                  tcl.entry_current->briefFile = tcl.file_name;
               }
               yyless(0);
               tcl_command(-1, tcl.string_commentcodify);
               tcl.string_commentline = "";
               tcl.string_commentcodify = "";
            }
            YY_BREAK
         case 30:
            /* rule 30 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify += text;

               text = text.left(text.length() - 3);
               text.append("\n");
               tcl.string_commentline += text;
            }
            YY_BREAK
         case 31:
            /* rule 31 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify += text;
               tcl.string_commentline += text;
               yy_pop_state();
            }
            YY_BREAK
         case 32:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  

               text = text.left(text.length() - 1);
               tcl.string_commentcodify += text;
               tcl.string_commentline += text;

               yy_pop_state();
               unput(0x1A);
            }
            YY_BREAK
         case 33:
            /* rule 33 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify = text;
               tcl.string_commentcodify = tcl.string_commentcodify.left(tcl.string_commentcodify.length() - 2);
               tcl.string_commentline = "";
               tcl.line_commentline = tclscannerYYlineno;
               tcl.line_body1 = tclscannerYYlineno;
               unput('<');
               unput('#');
               yy_push_state(COMMENTLINE);
            }
            YY_BREAK
         case 34:
            /* rule 34 can match eol */
            YY_RULE_SETUP

            {
               tcl.string_commentcodify = "";
               tcl.string_commentline = "";
               tcl.line_body1 = tclscannerYYlineno;
               tcl_command(-1, "");
            }
            YY_BREAK
         case 35:
            /* rule 35 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify = "";
               tcl.string_commentline = "";
               tcl.line_body1 = tclscannerYYlineno;
               tcl_command(-1, text);
            }
            YY_BREAK
         case 36:
            /* rule 36 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.string_commentcodify = "";
               tcl.string_commentline = "";
               tcl.line_body1 = tclscannerYYlineno - 1;
               tcl_command(-1, text);
            }
            YY_BREAK
         case 37:
            /* rule 37 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_command(1, text);
            }
            YY_BREAK
         case 38:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.word_is = ' ';
               tcl.string_last = "{*}";
               tcl_word(0, text.mid(3));
            }
            YY_BREAK
         case 39:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl.word_is = ' ';
               tcl.string_last = "";
               tcl_word(0, text);
            }
            YY_BREAK
         case 40:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  

               tcl.word_is = ' ';
               if (text[0] == '{' || text[0] == '[' || text[0] == '"')
               {
                  tcl.word_is = text[0];
               }
               tcl.string_last = "";
               tcl_word(0, text);
            }
            YY_BREAK
         case 41:

         case 42:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(1, text);
            }
            YY_BREAK
         case 43:
            /* rule 43 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(2, text);
            }
            YY_BREAK
         case 44:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(3, text);
            }
            YY_BREAK
         case 45:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(4, text);
            }
            YY_BREAK
         case 46:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(5, text);
            }
            YY_BREAK
         case 47:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(6, text);
            }
            YY_BREAK
         case 48:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(7, text);
            }
            YY_BREAK
         case 49:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(8, text);
            }
            YY_BREAK
         case 50:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(9, text);
            }
            YY_BREAK
         case 51:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(10, text);
            }
            YY_BREAK
         case 52:
            /* rule 52 can match eol */
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(11, text);
            }
            YY_BREAK
         case 53:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(12, text);
            }
            YY_BREAK
         case 54:
            YY_RULE_SETUP

            {
               QString text = QString::fromUtf8(tclscannerYYtext);  
               tcl_word(1, text);
            }
            YY_BREAK
         case 55:
            YY_RULE_SETUP

            ECHO;
            YY_BREAK


         case YY_END_OF_BUFFER: {
            /* Amount of text matched not including the EOB char. */
            int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

            /* Undo the effects of YY_DO_BEFORE_ACTION. */
            *yy_cp = (yy_hold_char);
            YY_RESTORE_YY_MORE_OFFSET

            if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW ) {
               /* We're scanning a new file or input source.  It's
                * possible that this happened because the user
                * just pointed tclscannerYYin at a new source and called
                * tclscannerYYlex().  If so, then we have to assure
                * consistency between YY_CURRENT_BUFFER and our
                * globals.  Here is the right place to do so, because
                * this is the first action (other than possibly a
                * back-up) that will match for the new input source.
                */
               (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
               YY_CURRENT_BUFFER_LVALUE->yy_input_file = tclscannerYYin;
               YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
            }

            /* Note that here we test for yy_c_buf_p "<=" to the position
             * of the first EOB in the buffer, since yy_c_buf_p will
             * already have been incremented past the NUL character
             * (since all states make transitions on EOB to the
             * end-of-buffer state).  Contrast this with the test
             * in input().
             */
            if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] ) {
               /* This was really a NUL. */
               yy_state_type yy_next_state;

               (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

               yy_current_state = yy_get_previous_state(  );

               /* Okay, we're now positioned to make the NUL
                * transition.  We couldn't have
                * yy_get_previous_state() go ahead and do it
                * for us because it doesn't know how to deal
                * with the possibility of jamming (and we don't
                * want to build jamming into it because then it
                * will run more slowly).
                */

               yy_next_state = yy_try_NUL_trans( yy_current_state );

               yy_bp = (yytext_ptr) + YY_MORE_ADJ;

               if ( yy_next_state ) {
                  /* Consume the NUL. */
                  yy_cp = ++(yy_c_buf_p);
                  yy_current_state = yy_next_state;
                  goto yy_match;
               }

               else {
                  yy_cp = (yy_c_buf_p);
                  goto yy_find_action;
               }
            }

            else switch ( yy_get_next_buffer(  ) ) {
                  case EOB_ACT_END_OF_FILE: {
                     (yy_did_buffer_switch_on_eof) = 0;

                     if ( tclscannerYYwrap( ) ) {
                        /* Note: because we've taken care in
                         * yy_get_next_buffer() to have set up
                         * tclscannerYYtext, we can now set up
                         * yy_c_buf_p so that if some total
                         * hoser (like flex itself) wants to
                         * call the scanner after we return the
                         * YY_NULL, it'll still work - another
                         * YY_NULL will get returned.
                         */
                        (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                        yy_act = YY_STATE_EOF(YY_START);
                        goto do_action;
                     }

                     else {
                        if ( ! (yy_did_buffer_switch_on_eof) ) {
                           YY_NEW_FILE;
                        }
                     }
                     break;
                  }

                  case EOB_ACT_CONTINUE_SCAN:
                     (yy_c_buf_p) =
                        (yytext_ptr) + yy_amount_of_matched_text;

                     yy_current_state = yy_get_previous_state(  );

                     yy_cp = (yy_c_buf_p);
                     yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                     goto yy_match;

                  case EOB_ACT_LAST_MATCH:
                     (yy_c_buf_p) =
                        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                     yy_current_state = yy_get_previous_state(  );

                     yy_cp = (yy_c_buf_p);
                     yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                     goto yy_find_action;
               }
            break;
         }

         default:
            YY_FATAL_ERROR(
               "fatal flex scanner internal error--no action found" );
      } /* end of action switch */
   } /* end of scanning one token */
} /* end of tclscannerYYlex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
   register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
   register char *source = (yytext_ptr);
   register int number_to_move, i;
   int ret_val;

   if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
      YY_FATAL_ERROR(
         "fatal flex scanner internal error--end of buffer missed" );

   if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 ) {
      /* Don't try to fill the buffer, so this is an EOF. */
      if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 ) {
         /* We matched a single character, the EOB, so
          * treat this as a final EOF.
          */
         return EOB_ACT_END_OF_FILE;
      }

      else {
         /* We matched some text prior to the EOB, first
          * process it.
          */
         return EOB_ACT_LAST_MATCH;
      }
   }

   /* Try to read more data. */

   /* First move last chars to start of buffer. */
   number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

   for ( i = 0; i < number_to_move; ++i ) {
      *(dest++) = *(source++);
   }

   if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
      /* don't do the read, it's not guaranteed to return an EOF,
       * just force an EOF
       */
   {
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
   }

   else {
      int num_to_read =
         YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

      while ( num_to_read <= 0 ) {
         /* Not enough room in the buffer - grow it. */

         /* just a shorter name for the current buffer */
         YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

         int yy_c_buf_p_offset =
            (int) ((yy_c_buf_p) - b->yy_ch_buf);

         if ( b->yy_is_our_buffer ) {
            int new_size = b->yy_buf_size * 2;

            if ( new_size <= 0 ) {
               b->yy_buf_size += b->yy_buf_size / 8;
            } else {
               b->yy_buf_size *= 2;
            }

            /* Include room in for 2 EOB chars. */
            b->yy_ch_buf = (char *)tclscannerYYrealloc((void *) b->yy_ch_buf, b->yy_buf_size + 2  );

         } else
            /* Can't grow it, we don't own it. */
         {
            b->yy_ch_buf = 0;
         }

         if ( ! b->yy_ch_buf )
            YY_FATAL_ERROR("fatal error - scanner input buffer overflow" );

         (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

         num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

      }

      if ( num_to_read > YY_READ_BUF_SIZE ) {
         num_to_read = YY_READ_BUF_SIZE;
      }

      /* Read in more data. */
      YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                (yy_n_chars), (size_t) num_to_read );

      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
   }

   if ( (yy_n_chars) == 0 ) {
      if ( number_to_move == YY_MORE_ADJ ) {
         ret_val = EOB_ACT_END_OF_FILE;
         tclscannerYYrestart(tclscannerYYin  );
      }

      else {
         ret_val = EOB_ACT_LAST_MATCH;
         YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
            YY_BUFFER_EOF_PENDING;
      }
   }

   else {
      ret_val = EOB_ACT_CONTINUE_SCAN;
   }

   if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
      /* Extend the array by 50%, plus the number we really need. */
      yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
      YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) tclscannerYYrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size  );
      if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
         YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
      }
   }

   (yy_n_chars) += number_to_move;
   YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
   YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

   (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

   return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state (void)
{
   register yy_state_type yy_current_state;
   register char *yy_cp;

   yy_current_state = (yy_start);

   for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp ) {
      register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
      if ( yy_accept[yy_current_state] ) {
         (yy_last_accepting_state) = yy_current_state;
         (yy_last_accepting_cpos) = yy_cp;
      }
      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
         yy_current_state = (int) yy_def[yy_current_state];
         if ( yy_current_state >= 179 ) {
            yy_c = yy_meta[(unsigned int) yy_c];
         }
      }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
   }

   return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
   register int yy_is_jam;
   register char *yy_cp = (yy_c_buf_p);

   register YY_CHAR yy_c = 1;
   if ( yy_accept[yy_current_state] ) {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
   }
   while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 179 ) {
         yy_c = yy_meta[(unsigned int) yy_c];
      }
   }
   yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
   yy_is_jam = (yy_current_state == 178);

   return yy_is_jam ? 0 : yy_current_state;
}

static void yyunput (int c, register char *yy_bp )
{
   register char *yy_cp;

   yy_cp = (yy_c_buf_p);

   /* undo effects of setting up tclscannerYYtext */
   *yy_cp = (yy_hold_char);

   if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) {
      /* need to shift things up to make room */
      /* +2 for EOB chars. */
      register int number_to_move = (yy_n_chars) + 2;
      register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                               YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
      register char *source =
         &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

      while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
         *--dest = *--source;
      }

      yy_cp += (int) (dest - source);
      yy_bp += (int) (dest - source);
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
         (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

      if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) {
         YY_FATAL_ERROR( "flex scanner push-back overflow" );
      }
   }

   *--yy_cp = (char) c;

   if ( c == '\n' ) {
      --tclscannerYYlineno;
   }

   (yytext_ptr) = yy_bp;
   (yy_hold_char) = *yy_cp;
   (yy_c_buf_p) = yy_cp;
}


static int yyinput (void)
{
   int c;

   *(yy_c_buf_p) = (yy_hold_char);

   if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR ) {
      /* yy_c_buf_p now points to the character we want to return.
       * If this occurs *before* the EOB characters, then it's a
       * valid NUL; if not, then we've hit the end of the buffer.
       */
      if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
         /* This was really a NUL. */
      {
         *(yy_c_buf_p) = '\0';
      }

      else {
         /* need more input */
         int offset = (yy_c_buf_p) - (yytext_ptr);
         ++(yy_c_buf_p);

         switch ( yy_get_next_buffer(  ) ) {
            case EOB_ACT_LAST_MATCH:
               /* This happens because yy_g_n_b()
                * sees that we've accumulated a
                * token and flags that we need to
                * try matching the token before
                * proceeding.  But for input(),
                * there's no matching to consider.
                * So convert the EOB_ACT_LAST_MATCH
                * to EOB_ACT_END_OF_FILE.
                */

               /* Reset buffer status. */
               tclscannerYYrestart(tclscannerYYin );

            /*FALLTHROUGH*/

            case EOB_ACT_END_OF_FILE: {
               if ( tclscannerYYwrap( ) ) {
                  return EOF;
               }

               if ( ! (yy_did_buffer_switch_on_eof) ) {
                  YY_NEW_FILE;
               }
#ifdef __cplusplus
               return yyinput();
#else
               return input();
#endif
            }

            case EOB_ACT_CONTINUE_SCAN:
               (yy_c_buf_p) = (yytext_ptr) + offset;
               break;
         }
      }
   }

   c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
   *(yy_c_buf_p) = '\0';	/* preserve tclscannerYYtext */
   (yy_hold_char) = *++(yy_c_buf_p);

   if ( c == '\n' )

   {
      tclscannerYYlineno++;
   }
   ;

   return c;
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void tclscannerYYrestart  (FILE *input_file )
{

   if ( ! YY_CURRENT_BUFFER ) {
      tclscannerYYensure_buffer_stack ();
      YY_CURRENT_BUFFER_LVALUE =
         tclscannerYY_create_buffer(tclscannerYYin, YY_BUF_SIZE );
   }

   tclscannerYY_init_buffer(YY_CURRENT_BUFFER, input_file );
   tclscannerYY_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void tclscannerYY_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{

   /* TODO. We should be able to replace this entire function body
    * with
    *		tclscannerYYpop_buffer_state();
    *		tclscannerYYpush_buffer_state(new_buffer);
     */
   tclscannerYYensure_buffer_stack ();
   if ( YY_CURRENT_BUFFER == new_buffer ) {
      return;
   }

   if ( YY_CURRENT_BUFFER ) {
      /* Flush out information for old buffer. */
      *(yy_c_buf_p) = (yy_hold_char);
      YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
   }

   YY_CURRENT_BUFFER_LVALUE = new_buffer;
   tclscannerYY_load_buffer_state( );

   /* We don't actually know whether we did this switch during
    * EOF (tclscannerYYwrap()) processing, but the only time this flag
    * is looked at is after tclscannerYYwrap() is called, so it's safe
    * to go ahead and always set it.
    */
   (yy_did_buffer_switch_on_eof) = 1;
}

static void tclscannerYY_load_buffer_state  (void)
{
   (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
   (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
   tclscannerYYin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
   (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE tclscannerYY_create_buffer  (FILE *file, int  size )
{
   YY_BUFFER_STATE b;

   b = (YY_BUFFER_STATE) tclscannerYYalloc(sizeof( struct yy_buffer_state )  );
   if ( ! b ) {
      YY_FATAL_ERROR( "out of dynamic memory in tclscannerYY_create_buffer()" );
   }

   b->yy_buf_size = size;

   /* yy_ch_buf has to be 2 characters longer than the size given because
    * we need to put in 2 end-of-buffer characters.
    */
   b->yy_ch_buf = (char *) tclscannerYYalloc(b->yy_buf_size + 2  );
   if ( ! b->yy_ch_buf ) {
      YY_FATAL_ERROR( "out of dynamic memory in tclscannerYY_create_buffer()" );
   }

   b->yy_is_our_buffer = 1;

   tclscannerYY_init_buffer(b, file );

   return b;
}

/** Destroy the buffer.
 * @param b a buffer created with tclscannerYY_create_buffer()
 *
 */
void tclscannerYY_delete_buffer (YY_BUFFER_STATE  b )
{

   if ( ! b ) {
      return;
   }

   if ( b == YY_CURRENT_BUFFER ) { /* Not sure if we should pop here. */
      YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
   }

   if ( b->yy_is_our_buffer ) {
      tclscannerYYfree((void *) b->yy_ch_buf  );
   }

   tclscannerYYfree((void *) b  );
}

#ifndef __cplusplus
extern int isatty (int );
#endif /* __cplusplus */

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a tclscannerYYrestart() or at EOF.
 */
static void tclscannerYY_init_buffer  (YY_BUFFER_STATE  b, FILE *file )

{
   int oerrno = errno;

   tclscannerYY_flush_buffer(b );

   b->yy_input_file = file;
   b->yy_fill_buffer = 1;

   /* If b is the current buffer, then tclscannerYY_init_buffer was _probably_
    * called from tclscannerYYrestart() or through yy_get_next_buffer.
    * In that case, we don't want to reset the lineno or column.
    */
   if (b != YY_CURRENT_BUFFER) {
      b->yy_bs_lineno = 1;
      b->yy_bs_column = 0;
   }

   b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;

   errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void tclscannerYY_flush_buffer (YY_BUFFER_STATE  b )
{
   if ( ! b ) {
      return;
   }

   b->yy_n_chars = 0;

   /* We always need two end-of-buffer characters.  The first causes
    * a transition to the end-of-buffer state.  The second causes
    * a jam in that state.
    */
   b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
   b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

   b->yy_buf_pos = &b->yy_ch_buf[0];

   b->yy_at_bol = 1;
   b->yy_buffer_status = YY_BUFFER_NEW;

   if ( b == YY_CURRENT_BUFFER ) {
      tclscannerYY_load_buffer_state( );
   }
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void tclscannerYYpush_buffer_state (YY_BUFFER_STATE new_buffer )
{
   if (new_buffer == NULL) {
      return;
   }

   tclscannerYYensure_buffer_stack();

   /* This block is copied from tclscannerYY_switch_to_buffer. */
   if ( YY_CURRENT_BUFFER ) {
      /* Flush out information for old buffer. */
      *(yy_c_buf_p) = (yy_hold_char);
      YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
   }

   /* Only push if top exists. Otherwise, replace top. */
   if (YY_CURRENT_BUFFER) {
      (yy_buffer_stack_top)++;
   }
   YY_CURRENT_BUFFER_LVALUE = new_buffer;

   /* copied from tclscannerYY_switch_to_buffer. */
   tclscannerYY_load_buffer_state( );
   (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void tclscannerYYpop_buffer_state (void)
{
   if (!YY_CURRENT_BUFFER) {
      return;
   }

   tclscannerYY_delete_buffer(YY_CURRENT_BUFFER );
   YY_CURRENT_BUFFER_LVALUE = NULL;
   if ((yy_buffer_stack_top) > 0) {
      --(yy_buffer_stack_top);
   }

   if (YY_CURRENT_BUFFER) {
      tclscannerYY_load_buffer_state( );
      (yy_did_buffer_switch_on_eof) = 1;
   }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void tclscannerYYensure_buffer_stack (void)
{
   int num_to_alloc;

   if (!(yy_buffer_stack)) {

      /* First allocation is just for 2 elements, since we don't know if this
       * scanner will even need a stack. We use 2 instead of 1 to avoid an
       * immediate realloc on the next call.
         */
      num_to_alloc = 1;
      (yy_buffer_stack) = (struct yy_buffer_state **)tclscannerYYalloc
                          (num_to_alloc * sizeof(struct yy_buffer_state *)
                          );
      if ( ! (yy_buffer_stack) ) {
         YY_FATAL_ERROR( "out of dynamic memory in tclscannerYYensure_buffer_stack()" );
      }

      memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state *));

      (yy_buffer_stack_max) = num_to_alloc;
      (yy_buffer_stack_top) = 0;
      return;
   }

   if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

      /* Increase the buffer to prepare for a possible push. */
      int grow_size = 8 /* arbitrary grow size */;

      num_to_alloc = (yy_buffer_stack_max) + grow_size;
      (yy_buffer_stack) = (struct yy_buffer_state **)tclscannerYYrealloc
                          ((yy_buffer_stack),
                           num_to_alloc * sizeof(struct yy_buffer_state *)
                          );
      if ( ! (yy_buffer_stack) ) {
         YY_FATAL_ERROR( "out of dynamic memory in tclscannerYYensure_buffer_stack()" );
      }

      /* zero only the new slots.*/
      memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state *));
      (yy_buffer_stack_max) = num_to_alloc;
   }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE tclscannerYY_scan_buffer(char *base, yy_size_t  size )
{
   YY_BUFFER_STATE b;

   if ( size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR || base[size - 1] != YY_END_OF_BUFFER_CHAR ) {
      /* They forgot to leave room for the EOB's. */   
      return 0;
   }

   b = (YY_BUFFER_STATE) tclscannerYYalloc(sizeof( struct yy_buffer_state )  );

   if ( ! b ) {
      YY_FATAL_ERROR( "out of dynamic memory in tclscannerYY_scan_buffer()" );
   }

   b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
   b->yy_buf_pos = b->yy_ch_buf = base;
   b->yy_is_our_buffer = 0;
   b->yy_input_file = 0;
   b->yy_n_chars = b->yy_buf_size;
   b->yy_is_interactive = 0;
   b->yy_at_bol = 1;
   b->yy_fill_buffer = 0;
   b->yy_buffer_status = YY_BUFFER_NEW;

   tclscannerYY_switch_to_buffer(b);

   return b;
}

/** Setup the input buffer state to scan a string. The next call to tclscannerYYlex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       tclscannerYY_scan_bytes() instead.
 */
YY_BUFFER_STATE tclscannerYY_scan_string (const QString &yystr )
{
   QByteArray tmp = yystr.toUtf8();
   return tclscannerYY_scan_bytes(tmp, tmp.length() );
}

/** Setup the input buffer state to scan the given bytes. The next call to tclscannerYYlex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE tclscannerYY_scan_bytes(yyconst char *yybytes, int  _yybytes_len )
{
   YY_BUFFER_STATE b;
   char *buf;
   yy_size_t n;
   int i;

   /* Get memory for full buffer, including space for trailing EOB's. */
   n = _yybytes_len + 2;
   buf = (char *) tclscannerYYalloc(n);

   if ( ! buf ) {
      YY_FATAL_ERROR( "out of dynamic memory in tclscannerYY_scan_bytes()" );
   }

   for ( i = 0; i < _yybytes_len; ++i ) {
      buf[i] = yybytes[i];
   }

   buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

   b = tclscannerYY_scan_buffer(buf, n );
   if ( ! b ) {
      YY_FATAL_ERROR( "bad buffer in tclscannerYY_scan_bytes()" );
   }

   /* It's okay to grow etc. this buffer, and we should throw it
    * away when we're done.
    */
   b->yy_is_our_buffer = 1;

   return b;
}

static void yy_push_state (int  new_state )
{
   if ( (yy_start_stack_ptr) >= (yy_start_stack_depth) ) {
      yy_size_t new_size;

      (yy_start_stack_depth) += YY_START_STACK_INCR;
      new_size = (yy_start_stack_depth) * sizeof( int );

      if ( ! (yy_start_stack) ) {
         (yy_start_stack) = (int *) tclscannerYYalloc(new_size  );
      }

      else {
         (yy_start_stack) = (int *) tclscannerYYrealloc((void *) (yy_start_stack), new_size  );
      }

      if ( ! (yy_start_stack) ) {
         YY_FATAL_ERROR( "out of memory expanding start-condition stack" );
      }
   }

   (yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;

   BEGIN(new_state);
}

static void yy_pop_state  (void)
{
   if ( --(yy_start_stack_ptr) < 0 ) {
      YY_FATAL_ERROR( "start-condition stack underflow" );
   }

   BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
}

static int yy_top_state  (void)
{
   return (yy_start_stack)[(yy_start_stack_ptr) - 1];
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char *msg )
{
   (void) fprintf( stderr, "%s\n", msg);
   exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up tclscannerYYtext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		tclscannerYYtext[tclscannerYYleng] = (yy_hold_char); \
		(yy_c_buf_p) = tclscannerYYtext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		tclscannerYYleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int tclscannerYYget_lineno  (void)
{

   return tclscannerYYlineno;
}

/** Get the input stream.
 *
 */
FILE *tclscannerYYget_in  (void)
{
   return tclscannerYYin;
}

/** Get the output stream.
 *
 */
FILE *tclscannerYYget_out  (void)
{
   return tclscannerYYout;
}

/** Get the length of the current token.
 *
 */
int tclscannerYYget_leng  (void)
{
   return tclscannerYYleng;
}

/** Get the current token.
 *
 */

char *tclscannerYYget_text(void)
{
   return tclscannerYYtext;
}

/** Set the current line number.
 * @param line_number
 *
 */
void tclscannerYYset_lineno (int  line_number )
{

   tclscannerYYlineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 *
 * @see tclscannerYY_switch_to_buffer
 */
void tclscannerYYset_in (FILE   *in_str )
{
   tclscannerYYin = in_str ;
}

void tclscannerYYset_out (FILE   *out_str )
{
   tclscannerYYout = out_str ;
}

int tclscannerYYget_debug  (void)
{
   return tclscannerYY_flex_debug;
}

void tclscannerYYset_debug (int  bdebug )
{
   tclscannerYY_flex_debug = bdebug ;
}

static int yy_init_globals (void)
{
   /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from tclscannerYYlex_destroy(), so don't allocate here.
   */

   /* We do not touch tclscannerYYlineno unless the option is enabled. */
   tclscannerYYlineno =  1;

   (yy_buffer_stack) = 0;
   (yy_buffer_stack_top) = 0;
   (yy_buffer_stack_max) = 0;
   (yy_c_buf_p) = (char *) 0;
   (yy_init) = 0;
   (yy_start) = 0;

   (yy_start_stack_ptr) = 0;
   (yy_start_stack_depth) = 0;
   (yy_start_stack) =  NULL;

   /* Defined in main.c */
#ifdef YY_STDINIT
   tclscannerYYin = stdin;
   tclscannerYYout = stdout;
#else
   tclscannerYYin = (FILE *) 0;
   tclscannerYYout = (FILE *) 0;
#endif

   /* For future reference: Set errno on error, since we are called by
    * tclscannerYYlex_init()
    */
   return 0;
}

/* tclscannerYYlex_destroy is for both reentrant and non-reentrant scanners. */
int tclscannerYYlex_destroy  (void)
{

   /* Pop the buffer stack, destroying each element. */
   while (YY_CURRENT_BUFFER) {
      tclscannerYY_delete_buffer(YY_CURRENT_BUFFER  );
      YY_CURRENT_BUFFER_LVALUE = NULL;
      tclscannerYYpop_buffer_state();
   }

   /* Destroy the stack itself. */
   tclscannerYYfree((yy_buffer_stack) );
   (yy_buffer_stack) = NULL;

   /* Destroy the start condition stack. */
   tclscannerYYfree((yy_start_stack)  );
   (yy_start_stack) = NULL;

   /* Reset the globals. This is important in a non-reentrant scanner so the next time
    * tclscannerYYlex() is called, initialization will occur. */
   yy_init_globals( );

   return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char *s1, yyconst char *s2, int n )
{
   register int i;
   for ( i = 0; i < n; ++i ) {
      s1[i] = s2[i];
   }
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char *s )
{
   register int n;
   for ( n = 0; s[n]; ++n )
      ;

   return n;
}
#endif

void *tclscannerYYalloc (yy_size_t  size )
{
   return (void *) malloc( size );
}

void *tclscannerYYrealloc  (void *ptr, yy_size_t  size )
{   
   return (void *) realloc( (char *) ptr, size );
}

void tclscannerYYfree (void *ptr )
{
   free( (char *) ptr );	/* see tclscannerYYrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

//! Start new scan context for given 'content'.
// @return created new scan context.
static tcl_scan *tcl_scan_start(QChar type, const QString &content_t, const QString &ns, QSharedPointer<Entry> entry_cl, 
                  QSharedPointer<Entry> entry_fn)
{
   QString content = content_t;

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);   
   }
  
   myScan->line1 = tclscannerYYlineno;
   yy_push_state(TOP);

   myScan = new tcl_scan;
   myScan->tclType = ' ';

   switch (type.unicode()) {
      case '"':
      case '{':
      case '[':
         myScan->tclType = type;
         break;

      case '?':
         if (content[0] == '"' && content[content.length() - 1] == '"') {
            myScan->tclType = '"';
         }

         if (content[0] == '{' && content[content.length() - 1] == '}') {
            myScan->tclType = '{';
         }

         if (content[0] == '[' && content[content.length() - 1] == ']') {
            myScan->tclType = '[';
         }
   }

   if (myScan->tclType != ' ') {
      tcl_codify(NULL, myScan->tclType);
      content = content.mid(1, content.length() - 2);
   }

   content += (char)0x1A;// for detection end of scan context
   myScan->ns = ns;
   myScan->entry_cl = entry_cl;
   myScan->entry_fn = entry_fn;
   myScan->entry_scan = tcl.entry_current;
   myScan->buffer_state = tclscannerYY_scan_string(content);
   myScan->line0 = tcl.line_body0;
   myScan->line1 = tcl.line_body1;
   myScan->after.clear();
   tclscannerYYlineno = myScan->line0;
   myScan->protection = tcl.protection;

   tcl.entry_inside = myScan->entry_scan;
   tcl.entry_current = tcl_entry_new();

   tcl.listScan.insert(0, myScan);

   tclscannerYY_switch_to_buffer(myScan->buffer_state);

   return (myScan);
}

//! Close current scan context.
static void tcl_scan_end()
{
   int len = tcl.listScan.length();

   tcl_scan *myScan  = nullptr;
   tcl_scan *myScan1 = nullptr;
   
   if (len > 0) {
      myScan  = tcl.listScan.at(0);
   }

   if (len > 1) {
      myScan1 = tcl.listScan.at(1);
   }

   tcl_inf("line=%d\n", myScan->line1);

   if (myScan->tclType == '{') {
      myScan->tclType = '}';
   }

   if (myScan->tclType == '[') {
      myScan->tclType = ']';
   }

   if (myScan->tclType != ' ') {
      tcl_codify(NULL, myScan->tclType);
   }

   int myStart = -1;
   for (unsigned int i = 0; i < myScan->after.count(); i = i + 2) {
      if (myScan->after[i] == "script") {
         myStart = i;
         break;
      }
      tcl_codify(myScan->after[i], myScan->after[i + 1]);
   }

   tclscannerYY_delete_buffer(myScan->buffer_state);
   yy_pop_state();
   tcl.entry_inside = myScan1->entry_scan;
   tclscannerYY_switch_to_buffer(myScan1->buffer_state);
   tclscannerYYlineno = myScan1->line1;
   tcl.protection = myScan1->protection;

   if (myStart >= 0) {
      myScan1 = tcl_scan_start('?', myScan->after[myStart + 1], myScan->ns, myScan->entry_cl, myScan->entry_fn);

      for (unsigned int i = myStart + 2; i < myScan->after.count(); i++) {
         myScan1->after.append(myScan->after[i]);
      }

      if (tcl.listScan.length() > 1 ) { 
         tcl.listScan.removeAt(1);
      }

   } else if (tcl.listScan.length() > 0 ) { 
      tcl.listScan.removeFirst();
   }
}

//! Handling of word parsing
static void tcl_word(int what, const QString &text)
{
   static QStack<QChar> myList;       // nesting level list  
   static int myWhite = 0;            // set true when next char should be whitespace

   static QChar myWord;               // internal state

   switch (what) {
      case 0:// start
         yy_push_state(WORD);

         switch (text[0].unicode() ) {
            case '{':
            case '[':
            case '"':
               myWord = text[0];
               break;

            default:
               myWord = '.';
         }

         myList.clear();
         myList.push(myWord); 

         myWhite = 0;

         break;

      case 1:// all other chars
         if (myWhite != 0) {
            // {x}y "x"y
            tcl_err("expected word separator: %s\n", qPrintable(text));
            return;
         }

         if (myList.isEmpty()) {
            myWord = '.';

            myList.push(myWord);           
         }
         break;

      case 2:// \\\n
         if (myList.isEmpty()) {
            myWord = ' ';

            yy_pop_state();
            yyless(0);
            tcl_inf("(\\\n) ?%s?\n", qPrintable(tcl.string_last));

            return;
         }

         switch (myList.top().unicode()) {
            case '{':
            case '[':
            case '"':
               break;

            case '.':
               if (myList.size() == 1) {
                  myWord = ' ';

                  yy_pop_state();
                  yyless(0);
                  tcl_inf("(\\\n) ?%s?\n", qPrintable(tcl.string_last));

                  return;
               }
               break;
         }

         myWhite = 0;
         break;

      case 3:// {
         if (myWhite != 0) {
            // {x}{ "x"{
            tcl_err("expected word separator: %s\n", qPrintable(text));
            return;
         }

         switch (myList.top().unicode()) {
            case '{':
            case '[': 
               myList.push('{');
               break;
 
            case '"':
            case '.':
               break;
         }

         myWhite = 0;
         break;

      case 4:// }
         if (myWhite != 0) {
            // {x}{ "x"{
            tcl_err("expected word separator: %s\n", qPrintable(text));
            return;
         }

         switch (myList.top().unicode()) {
            case '{':// {{x}}

               myList.pop();

               if (myList.isEmpty() && ! tcl.code) {
                  myWhite = 1;
               }

               break;

            case '[':
            case '"':
            case '.':
               break;
         }

         break;
      case 5:// [
         if (myWhite != 0) {
            // {x}[
            tcl_err("expected word separator: %s\n", qPrintable(text));
            return;
         }

         switch (myList.top().unicode()) {
            case '{':
               break;

            case '[':
            case '"':
            case '.':
               myList.push('[');
               break;
         }

         myWhite = 0;
         break;

      case 6:// ]
         if (myWhite != 0) {
            // {x}]
            tcl_err("expected word separator: %s\n", qPrintable(text));
            return;
         }

         switch (myList.top().unicode()) {
            case '{':
               break;

            case '[':
               myList.pop();
               break;

            case '"':
            case '.':
               break;
         }
         myWhite = 0;
         break;

      case 7:// "
         if (myWhite != 0) {
            // {x}"
            tcl_err("expected word separator: %s\n", qPrintable(text));
            return;
         }
         switch (myList.top().unicode()) {
            case '{':
               break;

            case '[':
               myList.push('"');             
               break;

            case '"':
               myList.pop();
               
            case '.':
               break;
         }
         break;

      case 8:// ' '
      case 9:// \t
      case 10:// ;
      case 11:// \n
         if (myList.isEmpty()) {
            myWord = ' ';

            yy_pop_state();
            yyless(0);
            tcl_inf("(%d) ?%s?\n", what, qPrintable(tcl.string_last));
            return;
         }

         switch (myList.top().unicode()) {
            case '{':
            case '[':
            case '"':
               break;

            case '.':
               if (myList.size() == 1) {
                  myWord = ' ';

                  yy_pop_state();
                  yyless(0);
                  tcl_inf("(.%d) ?%s?\n", what, qPrintable(tcl.string_last));

                  return;

               } else {
                  myList.pop();
                  
               }
               break;
         }
         myWhite = 0;
         break;

      case 12:// \x1A
         if (myList.isEmpty()) {
            myWord = ' ';

            yy_pop_state();
            yyless(0);
            tcl_inf("(%d) ?%s?\n", what, qPrintable(tcl.string_last));

            return;
         }

         if (myList.size() != 1 || myList[0] != '.') {
            tcl_war("level=%d expected=%c\n", myList.size(), myList.top());
         }

         myWord = ' ';
         yy_pop_state();
         yyless(0);
         tcl_inf("(.%d) ?%s?\n", what, qPrintable(tcl.string_last));

         return;      

      default:
         tcl_err("wrong state: %d\n", what);
         return;
   }

   tcl.string_last += text;
}

//! Handling of comment parsing.
static void tcl_comment(int what, const QString  &text)
{
   if (what == 0) {
      // begin of comment

      if (tcl.comment) {
         tcl_err("comment in comment\n");
         return;
      }

      yy_push_state(COMMENT);
      tcl_inf("<- %s\n", qPrintable(text));
      tcl.string_comment = "";
      tcl.comment = 0;

   } else if (what == 1) {
      // start new comment
      if (tcl.comment) {
         tcl_comment(99, ""); // inbody
      }

      tcl.string_comment = text;
      tcl.comment = 1;

   } else if (what == 2) {
      // add to comment
      if (tcl.comment) {
         tcl.string_comment += text;
      }

   } else if (what == -1 || what == -2) {
      // end of comment without/with command
      if (tcl.comment) {
         tcl.string_last = tcl.string_comment;
         tcl_comment(100 + what, "");

      } else {
         tcl.string_last = "";
         tcl_inf("-> %s\n", qPrintable(tcl.string_comment));
      }

      yy_pop_state();
      tcl.string_comment = "";
      tcl.comment = 0;

   } else if (what == 98 || what == 99) {
      // 98=new 99=inbody

      if (tcl.this_parser && tcl.string_comment.length()) {
         tcl_inf("-> %s\n", qPrintable(tcl.string_comment));
         int myPos  = 0;
         bool myNew = 0;
         int myLine = tcl.line_comment;

         QString myIn;
         QString myDoc;
         Protection myProt = tcl.protection;

         // resolve ALIASES
         myIn += "/*!";
         myIn += tcl.string_comment;
         myIn += "*/";

         myDoc = convertCppComments(myIn, tcl.file_name);
         myDoc = myDoc.mid(3);
        
         if (what == 99) {
            // inbody comment file or namespace or class or proc/method
            int myPos0;
            int myLine0;

            QSharedPointer<Entry> myEntry0 = QMakeShared<Entry>(); // used to test parsing

            QSharedPointer<Entry> myEntry;
            QSharedPointer<Entry> myEntry1;

            if (tcl.listScan.length() > 0 ) { 
               if (tcl.listScan.at(0)->entry_fn) {
                  myEntry1 = tcl.listScan.at(0)->entry_fn;
   
               } else if (tcl.listScan.at(0)->entry_cl) {
                  myEntry1 = tcl.listScan.at(0)->entry_cl;
   
               }
            }

            myPos0  = myPos;
            myLine0 = myLine;

            while (parseCommentBlock(tcl.this_parser, myEntry0, myDoc, tcl.file_name,
                                     myLine, FALSE, tcl.config_autobrief, FALSE, myProt, myPos, myNew)) {

               if (myNew) {
                  // we need a new entry in this case
                  myNew = 0;
                  myEntry = tcl_entry_new();

                  parseCommentBlock(tcl.this_parser, myEntry, myDoc, tcl.file_name,
                                    myLine0, FALSE, tcl.config_autobrief, FALSE, myProt, myPos0, myNew);

                  tcl.entry_inside->addSubEntry(myEntry, tcl.entry_inside);

               } else {
                  // we can add to current entry in this case
                  if (! myEntry1 && tcl.listScan.length() > 0) {
                     myEntry1 = tcl_entry_namespace(tcl.listScan.at(0)->ns);
                  }

                  parseCommentBlock(tcl.this_parser, myEntry1, myDoc, tcl.file_name,
                                    myLine0, FALSE, tcl.config_autobrief, FALSE, myProt, myPos0, myNew);
               }

               myPos0 = myPos;
               myLine0 = myLine;
            }

            if (myNew) {
               // we need a new entry
               myNew = 0;
               myEntry = tcl_entry_new();
               parseCommentBlock(tcl.this_parser, myEntry, myDoc, tcl.file_name,
                                 myLine0, FALSE, tcl.config_autobrief, FALSE, myProt, myPos0, myNew);

               tcl.entry_inside->addSubEntry(myEntry, tcl.entry_inside);

            } else {
               // we can add to current entry
               if (! myEntry1 && tcl.listScan.length() > 0) {
                  myEntry1 = tcl_entry_namespace(tcl.listScan.at(0)->ns);
               }

               parseCommentBlock(tcl.this_parser, myEntry1, myDoc, tcl.file_name,
                                 myLine0, FALSE, tcl.config_autobrief, FALSE, myProt, myPos0, myNew);
            }
         } else {
            // new entry
            tcl.entry_current = tcl_entry_new();

            while (parseCommentBlock(tcl.this_parser, tcl.entry_current, myDoc,
                                     tcl.file_name, myLine, FALSE, tcl.config_autobrief, FALSE,
                                     myProt, myPos, myNew)) {
               if (myNew) {
                  tcl.entry_inside->addSubEntry(tcl.entry_current, tcl.entry_inside);
                  tcl.entry_current = tcl_entry_new();

               } else {
                  tcl.entry_current->section = tcl.entry_inside->section;
                  tcl.entry_current->name = tcl.entry_inside->name;
               }
            }

            if (myNew) {
               tcl.entry_inside->addSubEntry(tcl.entry_current, tcl.entry_inside);
               tcl.entry_current = tcl_entry_new();
            } else {
               tcl.entry_current->section = tcl.entry_inside->section;
               tcl.entry_current->name = tcl.entry_inside->name;
            }
         }

         if (tcl.protection != myProt && tcl.listScan.length() > 0) {
            tcl.listScan.at(0)->protection = tcl.protection = myProt;
         }
      }
   } else {
      tcl_err("what %d\n", what);
      return;
   }
}

//! Parse given \c arglist .
static void tcl_command_ArgList(QString &arglist)
{
   Argument myArg;

   QStringList myArgs;
   QString myArglist = "";

   myArgs = tcl_split_list(arglist);

   for (uint i = 0; i < myArgs.count(); i++) {
      QStringList myArgs1;
     
      myArgs1 = tcl_split_list(myArgs[i]);

      if (myArgs1.count() == 2) {
         myArg.name   = myArgs1.at(0);
         myArg.defval = myArgs1.at(1);

         if (myArg.defval.isEmpty()) {
            myArg.defval = " ";
         }

         myArglist += "?" + myArg.name + "? ";

      } else {
         myArg.name = (myArgs.at(i));
         myArglist += QString(myArg.name) + " ";
      }

      tcl.entry_current->argList.append(myArg);
   }

   arglist = myArglist;
   tcl.entry_current->args = arglist;
}

//! Create link.
static void tcl_codify_link(const QString &name)
{
   if (tcl.code == NULL || name.isEmpty()) {
      return;
   }

   static int init = 0;
   static QMap<QString, QSharedPointer<MemberDef>> fn;

   if (init == 0) {
      init = 1;

      for (auto mn : *Doxy_Globals::memberNameSDict) { 
         for (auto md : *mn) {
            fn.insert(md->qualifiedName(), md);
         }
      }

      for (auto mn : *Doxy_Globals::functionNameSDict) {
         for (auto md : *mn) {
            fn.insert(md->qualifiedName(), md);
         }
      }
   }

   QSharedPointer<MemberDef> myDef;
   QString myName = name;

   if (name.mid(0, 2) == "::") { // fully qualified global command
      myName = myName.mid(2);
      myDef  = fn.value(myName);

   } else { 
      // not qualified name
      QString myName1 = myName;
      myDef = QSharedPointer<MemberDef>();

      if (tcl.listScan.length() > 0 ) {
         myName1 = tcl.listScan.at(0)->ns;
      }

      if (myName1 == " " || myName1 == "") {
         myName1 = myName;

      } else {
         myName1 = myName1 + "::" + myName;

      }

      myDef = fn.value(myName1); // search namespace command

      if (! myDef) {
         myDef = fn.value(myName); // search global command
      }
   }

   if (myDef) { // documented command
      tcl.code->writeCodeLink(myDef->getReference(), myDef->getOutputFileBase(), myDef->anchor(),
                              name, myDef->qualifiedName());

      if (tcl.memberdef) {
         myDef->addSourceReferencedBy(tcl.memberdef);
         tcl.memberdef->addSourceReferences(myDef);

      } else {
         QSharedPointer<Entry> callerEntry;
         unsigned int i;

         // walk the list of scan contexts and find the enclosing method or proc
         for (i = 0; i < tcl.listScan.length(); i++) {
            callerEntry = tcl.listScan.at(i)->entry_scan;

            if (callerEntry->mtype == Method && !callerEntry->name.isEmpty()) {
               break;
            }
         }

         if (i < tcl.listScan.length()) {
            // enclosing method found
            QString callerName = callerEntry->name;

            if (callerName.mid(0, 2) == "::") { // fully qualified global command
               callerName = callerName.mid(2);

            } else {
               if (! (tcl.listScan.at(0)->ns.trimmed().isEmpty())) {
                  callerName = tcl.listScan.at(0)->ns + "::" + callerEntry->name;
               }
            }

            QSharedPointer<MemberDef> callerDef;
            callerDef = fn.value(callerName);

            if (callerDef && myDef && tcl.collectXRefs) {
               addDocCrossReference(callerDef, myDef);
            }
         }
      }
   } else if (tcl_keyword(myName)) { // check keyword
      tcl_codify("keyword", name);

   } else {
      tcl_codify(NULL, name); // something else
   }

}

//! scan general argument for brackets
//
// parses (*tcl.listCommandwords.at(i)) and checks for brackets.
// Starts a new scan context if needed (*myScan==0 and brackets found).
// Returns NULL or the created scan context.

static tcl_scan *tcl_command_ARG(tcl_scan *myScan, unsigned int i, bool ignoreOutermostBraces)
{
   QString myName;

   bool insideQuotes = false;
   unsigned int insideBrackets = 0;
   unsigned int insideBraces = 0;

   myName = tcl.listCommandwords.at(i);

   if (i % 2 != 0) {
      // handle white space
      myScan = tcl_codify_token(myScan, "NULL", myName);

   } else {
      QString myStr = "";
      unsigned int j;

      for (j = 0; j < myName.length(); j++) {
         QChar c = myName[j];

         bool backslashed = false;

         if (j > 0) {
            backslashed = myName[j - 1] == '\\';
         }

         // this is a state machine
         // input is c
         // internal state is myScan and insideXXX
         // these are the transitions:
    
         if (c == '[' && !backslashed && insideBraces == 0) {
            insideBrackets++;
         }
         if (c == ']' && !backslashed && insideBraces == 0 && insideBrackets > 0) {
            insideBrackets--;
         }
         if (c == '{' && !backslashed && !insideQuotes && !(ignoreOutermostBraces && j == 0)) {
            insideBraces++;
         }
         if (c == '}' && !backslashed && !insideQuotes && insideBraces > 0) {
            insideBraces--;
         }
         if (c == '"' && !backslashed && insideBraces == 0) {
            insideQuotes = !insideQuotes;
         }

         // all output, depending on state and input
         if (c == '[' && !backslashed && insideBrackets == 1 && insideBraces == 0) {
            // the first opening bracket, output what we have so far
            myStr += c;
            myScan = tcl_codify_token(myScan, "NULL", myStr);
            myStr = "";

         } else if (c == ']' && !backslashed && insideBrackets == 0 && insideBraces == 0) {
            // the last closing bracket, start recursion, switch to deferred
            myScan = tcl_codify_token(myScan, "script", myStr);
            myStr = "";
            myStr += c;
         } else {
            myStr += c;
         }
      }

      if (i == 0 && myScan == NULL) {
         tcl_codify_link(myStr);

      } else {
         myScan = tcl_codify_token(myScan, "NULL", myStr);

      }
   }

   return (myScan);
}

//! Handle internal tcl commands.
// "eval arg ?arg ...?"
static void tcl_command_EVAL()
{   
   tcl_codify_cmd("keyword", 0);

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0 )  {
      myScan = tcl.listScan.at(0);
   }

   QString myString = "";

   // we simply rescan the line without the eval
   // we include leading whitespace because tcl_scan_start will examine
   // the first char. If it finds a bracket it will assume one expression in brackets.
   // Example: eval [list set] [list NotInvoked] [Invoked NotInvoked]

   for (int i = 1; i < tcl.listCommandwords.length(); i++) {
      myString += tcl.listCommandwords.at(i);
   }

   myScan = tcl_scan_start('?', myString, myScan->ns, myScan->entry_cl, myScan->entry_fn);
}

//! Handle internal tcl commands.
// switch ?options? string pattern body ?pattern body ...?
// switch ?options? string {pattern body ?pattern body ...?}
static void tcl_command_SWITCH()
{
   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_scan *myScan = nullptr;
   unsigned int i;
 
   QString token;

   // first: find the last option token
   unsigned int lastOptionIndex = 0;

   for (i = 2; i < tcl.listCommandwords.count(); i += 2) {
      token = tcl.listCommandwords.at(i);

      if (token == "--") {
         lastOptionIndex = i;
         break;
      }

      if (token[0] == '-' && i - lastOptionIndex == 2) {
         // options start with dash and should form a continuous chain
         lastOptionIndex = i;
      }
   }

   // second: eat up options
   for (i = 2; i <= lastOptionIndex; i++) {
      myScan = tcl_command_ARG(myScan, i, false);
   }

   // third: how many tokens are left?
   if (tcl.listCommandwords.count() - lastOptionIndex == 5) {

      myScan = tcl_command_ARG(myScan, lastOptionIndex + 1, false);
      myScan = tcl_command_ARG(myScan, lastOptionIndex + 2, false);
      myScan = tcl_command_ARG(myScan, lastOptionIndex + 3, false);

      // walk trough the list step by step
      // this way we can preserve whitespace

      bool inBraces = false;
      bool nextIsPattern = true;     

      token = tcl.listCommandwords.at(lastOptionIndex + 4);

      if (token[0] == '{') {
         inBraces = true;
         token    = token.mid(1, token.length() - 2);
         myScan   = tcl_codify_token(myScan, "NULL", QString("{"));
      }

      // ToDo: check if multibyte chars are handled correctly
      while (token.length() > 0) {

         QString tempToken = token;

         int elem;
         int next;
         int size;
         
         TclFindElement(tempToken, token.length(), elem, next, &size, nullptr);

         // handle leading whitespace/opening brace/double quotes
         if (elem > 0) {
            myScan = tcl_codify_token(myScan, "NULL", token.left(elem));
         }

         // handle actual element without braces/double quotes
         if (nextIsPattern) {
            myScan = tcl_codify_token(myScan, "NULL", token.mid(elem, size));

         } else {
            myScan = tcl_codify_token(myScan, "script", token.mid(elem, size));

         }

         // handle trailing whitespace/closing brace/double quotes
         if (next - elem - size > 0) {
            myScan = tcl_codify_token(myScan, "NULL", token.mid(elem + size, next - elem - size));
         }

         nextIsPattern = ! nextIsPattern;
         token = token.mid(next);
      }

      if (inBraces) {
         myScan = tcl_codify_token(myScan, "NULL", QString("}"));
      }

      if (! nextIsPattern) {
         tcl_war("Invalid switch syntax: last token is not a list of even elements\n");         
      }

   } else if ((tcl.listCommandwords.count() - lastOptionIndex > 6) &&
              ((tcl.listCommandwords.count() - lastOptionIndex - 3) % 4 == 0)) {

      myScan = tcl_command_ARG(myScan, lastOptionIndex + 1, false);
      myScan = tcl_command_ARG(myScan, lastOptionIndex + 2, false);

      for (i = lastOptionIndex + 3; i < tcl.listCommandwords.count(); i += 4) {
         myScan = tcl_command_ARG(myScan, i + 0, false); // whitespace
         myScan = tcl_command_ARG(myScan, i + 1, false); // pattern
         myScan = tcl_command_ARG(myScan, i + 2, false); // whitespace

         myScan = tcl_codify_token(myScan, "script", tcl.listCommandwords.at(i + 3)); // script
      }

   } else {
      // not properly detected syntax
      tcl_war("Invalid switch syntax: %d options followed by %d tokens.\n",
              lastOptionIndex / 2, (tcl.listCommandwords.count() - 1) / 2 - lastOptionIndex / 2);

      for (i = lastOptionIndex + 1; i <= tcl.listCommandwords.count(); i++) {
         myScan = tcl_command_ARG(myScan, i, false);
      }
   }
}

//! Handle internal tcl commands.
// "catch script ?resultVarName? ?optionsVarName?"
static void tcl_command_CATCH()
{   
   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   myScan = tcl_scan_start('?', tcl.listCommandwords.at(2), myScan->ns, myScan->entry_cl, myScan->entry_fn);

   for (unsigned int i = 3; i < tcl.listCommandwords.count(); i++) {
      myScan = tcl_command_ARG(myScan, i, false);
   }
}

//! Handle internal tcl commands.
// "if expr1 ?then? body1 elseif expr2 ?then? body2 elseif ... ?else?  ?bodyN?"
static void tcl_command_IF(QStringList type)
{
   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);

   tcl_scan *myScan = nullptr;
   myScan = tcl_command_ARG(myScan, 2, true);

   for (int i = 3; i < tcl.listCommandwords.length(); i++) {
      if (type[i] == "expr") {
         myScan = tcl_command_ARG(myScan, i, true);

      } else {
         if (myScan != nullptr) {
            myScan->after << type[i] << tcl.listCommandwords[i];

         } else if (tcl.listScan.length() > 0) {
            myScan = tcl.listScan.at(0);
            myScan = tcl_scan_start('?', tcl.listCommandwords.at(i), myScan->ns, myScan->entry_cl, myScan->entry_fn);
         }
      }
   }
}
//! Handle internal tcl commands.
// "for start test next body"
static void tcl_command_FOR()
{   
   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   myScan = tcl_scan_start('?', tcl.listCommandwords.at(2), myScan->ns, myScan->entry_cl, myScan->entry_fn);
   myScan->after << "NULL" << tcl.listCommandwords[3];
   myScan = tcl_command_ARG(myScan, 4, true);
   myScan->after << "NULL" << tcl.listCommandwords[5];
   myScan->after << "script" << tcl.listCommandwords[6];
   myScan->after << "NULL" << tcl.listCommandwords[7];
   myScan->after << "script" << tcl.listCommandwords[8];
}

///! Handle internal tcl commands.
// "foreach varname list body" and
// "foreach varlist1 list1 ?varlist2 list2 ...? body"
static void tcl_command_FOREACH()
{
   tcl_scan *myScan = nullptr;
   tcl_codify_cmd("keyword", 0);

   for (int i = 1; i < tcl.listCommandwords.count() - 1; i++) {
      myScan = tcl_command_ARG(myScan, i, false);
   }

   if (myScan != nullptr) {
      myScan->after << "script" << tcl.listCommandwords[tcl.listCommandwords.count() - 1];

   } else if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
      myScan = tcl_scan_start('?', tcl.listCommandwords.at(tcl.listCommandwords.count() - 1),
                              myScan->ns, myScan->entry_cl, myScan->entry_fn);
   }
}

///! Handle internal tcl commands.
// "while test body"
static void tcl_command_WHILE()
{
   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_scan *myScan = NULL;
   myScan = tcl_command_ARG(myScan, 2, true);
   myScan = tcl_command_ARG(myScan, 3, false);

   if (myScan != nullptr) {
      myScan->after << "script" << tcl.listCommandwords[4];

   } else if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
      myScan = tcl_scan_start('?', tcl.listCommandwords.at(4), myScan->ns, myScan->entry_cl, myScan->entry_fn);
   }
}

//! Handle all other commands.
// Create links of first command word or first command word inside [].
static void tcl_command_OTHER()
{
   tcl_scan *myScan = NULL;
   for (int i = 0; i < tcl.listCommandwords.length(); i++) {
      myScan = tcl_command_ARG(myScan, i, false);
   }
}

//! Handle \c proc statements.
static void tcl_command_PROC()
{
   QString myNs, myName;
   QSharedPointer<Entry> myEntryNs;
   QSharedPointer<Entry> myEntry;

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_codify_cmd(NULL, 2);
   tcl_codify_cmd(NULL, 3);
   tcl_codify_cmd(NULL, 4);
   tcl_codify_cmd(NULL, 5);
   tcl_name_SnippetAware(myScan->ns, tcl.listCommandwords.at(2), myNs, myName);

   if (myNs.length()) {
      myEntryNs = tcl_entry_namespace(myNs);
   } else {
      myEntryNs = tcl_entry_namespace(myScan->ns);
   }

   //why not needed here? tcl.fn.remove(myName);
   tcl.entry_current->section = Entry::FUNCTION_SEC;
   tcl.entry_current->mtype = Method;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;
   tcl_protection(tcl.entry_current);

   tcl_command_ArgList(tcl.listCommandwords[4]);

   myEntryNs->addSubEntry(tcl.entry_current, myEntryNs);

   myEntry = tcl.entry_current;
   tcl.fn.insert(myName, myEntry);
   myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(6), myEntryNs->name, QSharedPointer<Entry>(), myEntry);
}

//! Handle \c itcl::body statements and \c oo::define method and method inside \c itcl::class statements.
static void tcl_command_Method()
{   
   QString myNs, myName;

   QSharedPointer<Entry> myEntryCl;
   QSharedPointer<Entry> myEntry;

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_codify_cmd(NULL, 2);
   tcl_codify_cmd(NULL, 3);
   tcl_codify_cmd(NULL, 4);
   tcl_codify_cmd(NULL, 5);
   tcl_name(myScan->ns, tcl.listCommandwords.at(2), myNs, myName);

   if (myNs.length()) {
      myEntryCl = tcl_entry_class(myNs);
   } else {
      myNs = myScan->ns;
      myEntryCl = myScan->entry_cl;
   }

   // needed in case of more then one definition p.e. itcl::method and itcl::body
   // see also bug #
   tcl.fn.remove(myName);
   tcl.entry_current->section = Entry::FUNCTION_SEC;
   tcl.entry_current->mtype = Method;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;
   tcl_protection(tcl.entry_current);
   tcl_command_ArgList(tcl.listCommandwords[4]);

   myEntryCl->addSubEntry(tcl.entry_current, myEntryCl);

   tcl.fn.insert(myName, tcl.entry_current);
   myEntry = tcl.entry_current;
   myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(6), myNs, myEntryCl, myEntry);
}

//! Handle \c constructor statements inside class definitions.
static void tcl_command_Constructor()
{   
   QString myNs, myName;
   QSharedPointer<Entry> myEntryCl;
   QSharedPointer<Entry> myEntry;

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_codify_cmd(NULL, 2);
   tcl_codify_cmd(NULL, 3);
   tcl_name(myScan->ns, tcl.listCommandwords.at(0), myNs, myName);

   if (myNs.length()) {
      myEntryCl = tcl_entry_class(myNs);
   } else {
      myNs = myScan->ns;
      myEntryCl = myScan->entry_cl;
   }

   tcl.entry_current->section = Entry::FUNCTION_SEC;
   tcl.entry_current->mtype = Method;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;
   tcl_protection(tcl.entry_current);

   tcl_command_ArgList(tcl.listCommandwords[2]);

   if (myEntryCl) {
      myEntryCl->addSubEntry(tcl.entry_current, myEntryCl);
   }

   myEntry = tcl.entry_current;
   tcl.fn.insert(myName, myEntry);
   myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(4), myNs, myEntryCl, myEntry);
}

//! Handle \c destructor statements inside class definitions.
static void tcl_command_DESTRUCTOR()
{   
   QString myNs, myName;
   QSharedPointer<Entry> myEntryCl;
   QSharedPointer<Entry> myEntry;

   tcl_scan *myScan = nullptr;

   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_name(myScan->ns, tcl.listCommandwords.at(0), myNs, myName);
 
  if (myNs.length()) {
      myEntryCl = tcl_entry_class(myNs);
   } else {
      myNs = myScan->ns;
      myEntryCl = myScan->entry_cl;
   }
   tcl.entry_current->section = Entry::FUNCTION_SEC;
   tcl.entry_current->mtype = Method;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;
   tcl_protection(tcl.entry_current);

   myEntryCl->addSubEntry(tcl.entry_current, myEntryCl);
   myEntry = tcl.entry_current;
   tcl.fn.insert(myName, myEntry);

   myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(2), myNs, myEntryCl, myEntry);
}

//! Handle \c namespace statements.
static void tcl_command_NAMESPACE()
{   
   QString myNs, myName, myStr;

   tcl_scan *myScan = nullptr;
   
   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_codify_cmd("keyword", 2);
   tcl_codify_cmd(NULL, 3);
   tcl_codify_cmd(NULL, 4);
   tcl_codify_cmd(NULL, 5);

   tcl_name(myScan->ns, tcl.listCommandwords.at(4), myNs, myName);

   if (myNs.length()) {
      myName = myNs + "::" + myName;
   }

   tcl.entry_current->section = Entry::NAMESPACE_SEC;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;

   tcl.entry_main->addSubEntry(tcl.entry_current, tcl.entry_main);
   tcl.ns.insert(myName, tcl.entry_current);

   myStr = tcl.listCommandwords.at(6);

   if (tcl.listCommandwords.count() > 7) {
      for (uint i = 7; i < tcl.listCommandwords.count(); i++) {
         myStr.append(tcl.listCommandwords.at(i));
      }

      tcl.word_is = ' ';
   }

   myScan = tcl_scan_start(tcl.word_is, myStr, myName, QSharedPointer<Entry>(), QSharedPointer<Entry>());
}

//! Handle \c itcl::class statements.
static void tcl_command_ITCL_CLASS()
{   
   QString myNs;
   QString myName;

   QSharedPointer<Entry> myEntryCl;

    tcl_scan *myScan = nullptr;
   
   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);        
   tcl_codify_cmd("NULL", 2);
   tcl_codify_cmd("NULL", 3);

   tcl_name(myScan->ns, tcl.listCommandwords.at(2), myNs, myName);

   if (myNs.length()) {
      myName = myNs + "::" + myName;
   }

   tcl.entry_current->section = Entry::CLASS_SEC;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;

   tcl.entry_main->addSubEntry(tcl.entry_current, tcl.entry_main);

   tcl.cl.insert(myName, tcl.entry_current);

   myEntryCl = tcl.entry_current;
   myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(4), myName, myEntryCl, QSharedPointer<Entry>());
}

//! Handle \c oo::class statements.
static void tcl_command_OO_CLASS()
{
   QString myNs;
   QString myName;

   QSharedPointer<Entry> myEntryCl;

   tcl_scan *myScan = nullptr;
   
   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_codify_cmd("NULL", 2);
   tcl_codify_cmd("NULL", 3);
   tcl_codify_cmd("NULL", 4);
   tcl_codify_cmd("NULL", 5);
   tcl_name(myScan->ns, tcl.listCommandwords.at(4), myNs, myName);

   if (myNs.length()) {
      myName = myNs + "::" + myName;
   }
   tcl.entry_current->section = Entry::CLASS_SEC;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;

   tcl.entry_main->addSubEntry(tcl.entry_current, tcl.entry_main);

   tcl.cl.insert(myName, tcl.entry_current);
   myEntryCl = tcl.entry_current;
   myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(6), myName, myEntryCl, QSharedPointer<Entry>());
}

//! Handle \c oo::define statements.
static void tcl_command_OO_DEFINE()
{
   QString myNs, myName, myStr;
   QSharedPointer<Entry> myEntryCl;

   tcl_scan *myScan = nullptr;
   
   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   tcl_codify_cmd(NULL, 1);
   tcl_codify_cmd("NULL", 2);
   tcl_codify_cmd("NULL", 3);

   tcl_name(myScan->ns, tcl.listCommandwords.at(2), myNs, myName);
   if (myNs.length()) {
      myName = myNs + "::" + myName;
   }

   myEntryCl = tcl_entry_class(myName);
   myStr = tcl.listCommandwords.at(4);
   
   // special cases first
   // oo::define classname method methodname args script
   // oo::define classname constructor argList bodyScript
   // oo::define classname destructor bodyScript
   unsigned int n = tcl.listCommandwords.count();

   if ((myStr == "method"      && n == 11) || (myStr == "constructor" && n == 9) || (myStr == "destructor"  && n == 7)) {

      for (unsigned int i = 4; i < n - 1; i++) {
         tcl_codify_cmd("NULL", i);
      }

      QSharedPointer<Entry> myEntry;
      QString myMethod;

      tcl_name(myScan->ns, tcl.listCommandwords.at(n == 11 ? 6 : 4), myNs, myMethod);

      // code snippet taken from tcl_command_Method()/tcl_command_Constructor
      tcl.fn.remove(myMethod);
   
      tcl.entry_current->section = Entry::FUNCTION_SEC;
      tcl.entry_current->mtype = Method;
      tcl.entry_current->name = myMethod;
      tcl.entry_current->startLine = tcl.line_command;
      tcl.entry_current->bodyLine = tcl.line_body0;
      tcl.entry_current->endBodyLine = tcl.line_body1;
      tcl_protection(tcl.entry_current);
   
      if (n == 11) {
         tcl_command_ArgList(tcl.listCommandwords[8]);

      } else if (n == 9) {
         tcl_command_ArgList(tcl.listCommandwords[6]);
      }

      if (myEntryCl) {
         myEntryCl->addSubEntry(tcl.entry_current, myEntryCl);
      }

      tcl.fn.insert(myMethod, tcl.entry_current);
      myEntry = tcl.entry_current;
      myScan = tcl_scan_start('?', tcl.listCommandwords.at(n - 1), myNs, myEntryCl, myEntry);

   } else {
      // The general case
      // Simply concat all arguments into a script.
      // Note: all documentation collected just before the
      // oo::define command is lost
      if (tcl.listCommandwords.count() > 5) {

         for (uint i = 5; i < tcl.listCommandwords.count(); i++) {
            myStr.append(tcl.listCommandwords.at(i));
         }
         tcl.word_is = ' ';
      }

      myScan = tcl_scan_start(tcl.word_is, myStr, myName, myEntryCl, QSharedPointer<Entry>());
   }
}

//! Handle \c variable statements.
static void tcl_command_Variable(int inclass)
{   
   QString myNs, myName;
   QSharedPointer<Entry> myEntry;

   tcl_scan *myScan = nullptr;
   
   if (tcl.listScan.length() > 0) {
      myScan = tcl.listScan.at(0);
   }

   tcl_codify_cmd("keyword", 0);
   for (unsigned int i = 1; i < tcl.listCommandwords.length(); i++) {
      tcl_codify_cmd(NULL, i);
   }

   tcl_name(myScan->ns, tcl.listCommandwords.at(2), myNs, myName);

   if (myNs.length()) {
      // qualified variables go into namespace
      myEntry = tcl_entry_namespace(myNs);
      tcl.entry_current->stat = true;

   } else {
      if (inclass) {
         myEntry = myScan->entry_cl;
         tcl.entry_current->stat = false;
      } else {
         myEntry = tcl_entry_namespace(myScan->ns);
         tcl.entry_current->stat = true;
      }
   }
   tcl.entry_current->section = Entry::VARIABLE_SEC;
   tcl.entry_current->name = myName;
   tcl.entry_current->startLine = tcl.line_command;
   tcl.entry_current->bodyLine = tcl.line_body0;
   tcl.entry_current->endBodyLine = tcl.line_body1;
   tcl_protection(tcl.entry_current);

   myEntry->addSubEntry(tcl.entry_current, myEntry);

   tcl.entry_current = tcl_entry_new();
}

//! Handling of command parsing.
//! what=0  -> ...
//! what=1  -> ...
//! what=-1 -> ...
static void tcl_command(int what, const QString &text)
{
   int myLine = 0;

   if (what == 0) {
      tcl.listScan.at(0)->line1 = tclscannerYYlineno;    // current line in scan context

      tcl.line_body0 = tclscannerYYlineno;               // start line of command
      tcl_inf("<- %s\n", qPrintable(text));
      yy_push_state(COMMAND);

      tcl.listCommandwords.clear();
      tcl.string_command = "";
      tcl.string_last = "";
      tcl.command = 1;
      return;

   } else if (what == 1) {
      if (tcl.string_last.length()) {
         tcl.listCommandwords.append(tcl.string_last);
         tcl.string_last = "";
      }

      if (! text.isEmpty() ) {
         tcl.listCommandwords.append(text);
      }
      return;

   } else if (what != -1) {
      // should not happen
      tcl_err("what %d\n", what);
      return;
   }

   QString myText = text;
   tcl_inf("->\n");

   if (tcl.command == 0) {
      return; //TODO check on inside comment
   }

   if (tcl.string_last != "") {
      // get last word
      tcl.listCommandwords.append(tcl.string_last);
      tcl.string_last = "";
   }
   yy_pop_state();

   // check command
   QString myStr;
   tcl_scan *myScanBackup = nullptr;

   if (tcl.listCommandwords.length() > 0 ) { 
      myStr = tcl.listCommandwords.at(0);
   }
 
   if (tcl.listScan.length() > 0 ) { 
      myScanBackup = tcl.listScan.at(0);
   }

   int myLevel = 0;
   Protection myProt = tcl.protection;

   if (tcl.listCommandwords.length() < 3) {
      tcl_command_OTHER();
      goto command_end;
   }

   // remove leading "::" and apply TCL_SUBST
   if (myStr.left(2) == "::") {
      myStr = myStr.mid(2);
   }

   if (tcl.config_subst.contains(myStr)) {
      myStr = tcl.config_subst[myStr];
   }

   if (myStr == "private") {
      tcl.protection = Private;
      myLevel = 1;

   } else if (myStr == "protected") {
      tcl.protection = Protected;
      myLevel = 1;

   } else if (myStr == "public") {
      tcl.protection = Public;
      myLevel = 1;
   }

   if (myLevel) {
      tcl_codify_cmd("keyword", 0);
      tcl_codify_cmd(NULL, 1);

      tcl.listCommandwords.removeOne(tcl.listCommandwords.at(1));
      tcl.listCommandwords.removeOne(tcl.listCommandwords.at(0));

      if (tcl.listScan.length() > 0 && tcl.listCommandwords.length() == 1) {
         tcl_scan *myScan = tcl.listScan.at(0);

         myScan = tcl_scan_start(tcl.word_is, tcl.listCommandwords.at(0), myScan->ns, myScan->entry_cl, myScan->entry_fn);

         myProt = tcl.protection;
         goto command_end;
      }

      myStr  = tcl.listCommandwords.at(0);

      // remove leading "::" and apply TCL_SUBST
      if (myStr.left(2) == "::") {
         myStr = myStr.mid(2);
      }

      if (tcl.config_subst.contains(myStr)) {
         myStr = tcl.config_subst[myStr];
      }
   }

   if (myStr == "proc") {
      if (tcl.listCommandwords.count() == 5) {
         // itcl::proc
         tcl.listCommandwords.append("");
         tcl.listCommandwords.append("");
      }

      if (tcl.listCommandwords.count() != 7) {
         myLine = __LINE__;
         goto command_warn;
      }

      tcl_command_PROC();
      goto command_end;
   }

   if (myStr == "method") {
      if (tcl.listCommandwords.count() == 5) {
         // itcl::method
         tcl.listCommandwords.append("");
         tcl.listCommandwords.append("");
      }
      if (tcl.listCommandwords.count() != 7) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_Method();
      goto command_end;
   }

   if (myStr == "constructor") {
      if (tcl.listCommandwords.count() != 5) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_Constructor();
      goto command_end;
   }

   if (myStr == "destructor") {
      if (tcl.listCommandwords.count() != 3) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_DESTRUCTOR();
      goto command_end;
   }

   if (myStr == "namespace") {
      if (tcl.listCommandwords.at(2) == "eval") {
         if (tcl.listCommandwords.count() < 7) {
            myLine = __LINE__;
            goto command_warn;
         }
         tcl_command_NAMESPACE();
         goto command_end;
      }
      tcl_command_OTHER();
      goto command_end;
   }

   if (myStr == "itcl::class") {
      if (tcl.listCommandwords.count() != 5) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_ITCL_CLASS();
      goto command_end;
   }

   if (myStr == "itcl::body") {
      if (tcl.listCommandwords.count() != 7) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_Method();
      goto command_end;
   }

   if (myStr == "oo::class") {
      if (tcl.listCommandwords.at(2) == "create") {
         if (tcl.listCommandwords.count() != 7) {
            myLine = __LINE__;
            goto command_warn;
         }
         tcl_command_OO_CLASS();
         goto command_end;
      }
      tcl_command_OTHER();
      goto command_end;
   } 

   if (myStr == "oo::define") {
      if (tcl.listCommandwords.length() < 5) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_OO_DEFINE();
      goto command_end;
   }

   if (myStr == "variable") {

      if (tcl.listCommandwords.length() < 3) {
         myLine = __LINE__;
         goto command_warn;
      }

      if (tcl.listScan.length() > 0 && tcl.listScan.at(0)->entry_fn == NULL) {
         // only parsed outside functions
         tcl_command_Variable(tcl.listScan.at(0)->entry_cl && tcl.listScan.at(0)->entry_cl->name != "");
         goto command_end;
      }
   }

   if (myStr == "common") {
      if (tcl.listCommandwords.count() < 3) {
         myLine = __LINE__;
         goto command_warn;
      }
      if (tcl.listScan.at(0)->entry_fn == NULL) {
         // only parsed outside functions
         tcl_command_Variable(0);
         goto command_end;
      }
   }

   if (myStr == "inherit" || myStr == "superclass") {
      if (tcl.listCommandwords.count() < 3) {
         myLine = __LINE__;
         goto command_warn;
      }

      if (tcl.listScan.at(0)->entry_cl && tcl.listScan.at(0)->entry_cl->name != "") {
         for (unsigned int i = 2; i < tcl.listCommandwords.count(); i = i + 2) {
            tcl.listScan.at(0)->entry_cl->extends.append(BaseInfo(tcl.listCommandwords.at(i), Public, Normal));
         }
      }
      goto command_end;
   }

   /*
    * Start of internal tcl keywords
    * Ready: switch, eval, catch, if, for, foreach, while
    */
   if (myStr == "switch") {
      if (tcl.listCommandwords.length() < 5) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_SWITCH();
      goto command_end;
   }

   if (myStr == "eval") {
      if (tcl.listCommandwords.length() < 3) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_EVAL();
      goto command_end;
   }
   if (myStr == "catch") {
      if (tcl.listCommandwords.length() < 3) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_CATCH();
      goto command_end;
   }
   if (myStr == "for") {
      if (tcl.listCommandwords.length() != 9) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_FOR();
      goto command_end;
   }
   if (myStr == "foreach") {
      if (tcl.listCommandwords.length() < 7 || tcl.listCommandwords.length() % 2 == 0) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_FOREACH();
      goto command_end;
   }
   /*
   if expr1 ?then? body1 elseif expr2 ?then? body2 elseif ... ?else?  ?bodyN?
   */
   if (myStr == "if" && tcl.listCommandwords.length() > 4) {
      QStringList myType;

      myType << "keyword" << "NULL" << "expr" << "NULL";
      char myState = 'x'; // last word: e'x'pr 't'hen 'b'ody 'e'lse else'i'f..

      for (unsigned int i = 4; i < tcl.listCommandwords.count(); i = i + 2) {
         QString myStr = tcl.listCommandwords.at(i);

         if (myState == 'x') {
            if (myStr == "then") {
               myState = 't';
               myType << "keyword" << "NULL";
            } else {
               myState = 'b';
               myType << "script" << "NULL";
            }

         } else if (myState == 't') {
            myState = 'b';
            myType << "script" << "NULL";

         } else if (myState == 'b') {
            if (myStr == "elseif") {
               myState = 'i';
               myType << "keyword" << "NULL";
            } else if (myStr == "else" && i == tcl.listCommandwords.count() - 3) {
               myState = 'b';
               myType << "keyword" << "NULL" << "script";
               i = tcl.listCommandwords.count();
            } else if (i == tcl.listCommandwords.count() - 1) {
               myState = 'b';
               myType << "script";
               i = tcl.listCommandwords.count();
            } else {
               myLine = __LINE__;
               goto command_warn;
            }
         } else if (myState == 'i') {
            myState = 'x';
            myType << "expr" << "NULL";
         }
      }
      if (myState != 'b') {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_IF(myType);
      goto command_end;
   }

   if (myStr == "while") {
      if (tcl.listCommandwords.count() != 5) {
         myLine = __LINE__;
         goto command_warn;
      }
      tcl_command_WHILE();
      goto command_end;
   }

   tcl_command_OTHER();
   goto command_end;

command_warn:
   // print warning message because of wrong used syntax
   tcl_war("%d count=%d: %s\n", myLine, tcl.listCommandwords.count(), qPrintable(tcl.listCommandwords.join(" ")) );
   tcl_command_OTHER();

command_end:
   // add remaining text to current context
   if (! myText.isEmpty()) {

      if (tcl.listScan.length() > 0) {

         if (myScanBackup == tcl.listScan.at(0)) {
            tcl_codify("comment", myText);
   
         } else {
            tcl.listScan.at(0)->after << "comment" << myText;
         }

      }
   }

   tcl.listCommandwords.clear();
   tcl.command = 0;
   tcl.protection = myProt;
}

//! Common initializations.
static void tcl_init()
{
   // Get values from option TCL_SUBST
   tcl.config_subst.clear();

   QStringList myStrList = Config::getList("tcl-subst");

   for (auto s : myStrList) {
  
      QString myStr = s;
      int i = myStr.indexOf('=');

      if (i > 0) {
         QString myName  = myStr.left(i).trimmed();
         QString myValue = myStr.right(myStr.length() - i - 1).trimmed();

         if (! myName.isEmpty() && ! myValue.isEmpty()) {
            tcl_inf("TCL_SUBST: use '%s'\n", qPrintable(s));
         }

         tcl.config_subst[myName] = myValue;
      }         
   }
 

   if (tcl.input_string.at(tcl.input_string.length() - 1) == 0x1A) {
      // no code

   } else if (tcl.input_string.at(tcl.input_string.length() - 1) == '\n') {
      tcl.input_string[tcl.input_string.length() - 1] = 0x1A;

   } else {
      tcl.input_string += 0x1A;

   }

   tcl.code      = nullptr;
   tcl.code_font = "";
   tcl.code_line = 1;
   tcl.code_linenumbers = 1;
   tcl.config_autobrief = Config::getBool("javadoc-auto-brief");
   tcl.input_position = 0;
   tcl.file_name   = "";
   tcl.this_parser = NULL;
   tcl.command = 0;
   tcl.comment = 0;
   tcl.brace_level = 0;
   tcl.bracket_level = 0;
   tcl.bracket_quote = 0;
   tcl.word_is = ' ';
   tcl.string_command       = "";
   tcl.string_commentline   = "";
   tcl.string_commentcodify = "";
   tcl.string_comment       = "";
   tcl.string_last          = "";

   tcl.entry_main        = QSharedPointer<Entry>();
   tcl.entry_file        = QSharedPointer<Entry>();
   tcl.entry_current     = QSharedPointer<Entry>();
   tcl.entry_inside      = QSharedPointer<Entry>();

   tcl.listCommandwords.clear();
   tcl.listScan.clear();
   tcl.ns.clear();
   tcl.cl.clear();
   tcl.fn.clear();

   tclscannerYYlineno = 1;
   tcl.protection     = Public;
   tcl.memberdef      = QSharedPointer<MemberDef>();
}

//! Start parsing.
static void tcl_parse(const QString ns, const QString cls)
{
   tcl_scan *myScan = nullptr;

   tcl.entry_file          = tcl_entry_new();
   tcl.entry_file->name    = tcl.file_name;
   tcl.entry_file->section = Entry::SOURCE_SEC;
   tcl.entry_file->protection = Public;

   tcl.entry_main->addSubEntry(tcl.entry_file, tcl.entry_main);

   QSharedPointer<Entry> myEntry = tcl_entry_new();

   myEntry->name = "";
   tcl.entry_main->addSubEntry(myEntry, tcl.entry_main);
   tcl.ns.insert("::", myEntry);
   tcl.entry_current = tcl_entry_new();

   tclscannerYYrestart( tclscannerYYin );
   BEGIN( TOP );
   tclscannerYYlineno = 1;

   myScan = new tcl_scan;
   myScan->tclType = ' ';

   myScan->after.clear();
   myScan->line0 = tclscannerYYlineno;
   myScan->line1 = tclscannerYYlineno;
   myScan->buffer_state = YY_CURRENT_BUFFER;
   myScan->ns = ns;

   myScan->entry_cl = tcl_entry_class(cls);
   myScan->entry_fn = QSharedPointer<Entry>();

   tcl.entry_inside = tcl.entry_file;
   myScan->entry_scan = tcl.entry_inside;
   tcl.listScan.insert(0, myScan);

   tclscannerYYlex();

   tcl.listScan.clear();
   tcl.ns.clear();
   tcl.cl.clear();
   tcl.fn.clear();
   tcl.entry.clear();
}

//! Parse text file and build up entry tree.
void TclLanguageParser::parseInput(const QString &fileName, const QString &input, QSharedPointer<Entry> root,
                 enum ParserMode mode, QStringList &includedFiles, bool useClang)
{
   QFile  myFile;
   tcl_inf("%s\n", qPrintable(fileName) );

   myFile.setFileName(fileName);
   if (! myFile.open(QIODevice::ReadOnly)) {
      return;
   }

   if (input.isEmpty()) {
      return;
   }

   tcl.input_string = input;
 
   printlex(tclscannerYY_flex_debug, TRUE, __FILE__, fileName);

   msg("Parsing %s\n", qPrintable(fileName));
   groupEnterFile(fileName, tclscannerYYlineno);

   tcl_init();
   tcl.code = NULL;
   tcl.file_name   = fileName;
   tcl.this_parser = this;
   tcl.entry_main          = root; /* toplevel entry */
   tcl_parse("", "");

   groupLeaveFile(tcl.file_name, tclscannerYYlineno);
   root->m_program.resize(0);
   myFile.close();

   printlex(tclscannerYY_flex_debug, FALSE, __FILE__, fileName);
}

//! Parse file and codify.
void TclLanguageParser::parseCode(CodeOutputInterface &codeOutIntf, const QString &scopeName, const QString &input,
                  SrcLangExt lang, bool isExampleBlock, const QString &exampleName, QSharedPointer<FileDef> fileDef, int startLine,
                  int endLine, bool inlineFragment, QSharedPointer<MemberDef> memberDef, bool showLineNumbers, 
                  QSharedPointer<Definition> searchCtx, bool collectXRefs)
{
   if (input.length() < 1) {
      return;
   }

   printlex(tclscannerYY_flex_debug, TRUE, __FILE__, fileDef ? qPrintable(fileDef->fileName()) : "" );
   tcl.input_string = input;

   QString myNs  = "";
   QString myCls = "";

   if (memberDef) {
      if (memberDef->getClassDef()) {
         myCls = memberDef->getClassDef()->displayName();
         myNs = myCls;

      } else if (memberDef->getNamespaceDef()) {
         myNs = memberDef->getNamespaceDef()->displayName();
      }
   }

   QString myStr = "Codifying..";

   if (! scopeName.isEmpty()) {
      myStr += " scope=";
      myStr += scopeName;
   }

   if (! exampleName.isEmpty()) {
      myStr += " example=";
      myStr += exampleName;
   }

   if (memberDef) {
      myStr += " member=";
      myStr += memberDef->memberTypeName();
      myStr += " ";
      myStr += memberDef->qualifiedName();
   }
   if (fileDef) {
      myStr += " file=";
      myStr += fileDef->fileName();
   }

   tcl_inf("%s (%d,%d) %d %d\n", qPrintable(myStr), startLine, endLine, isExampleBlock, inlineFragment);

   if (isExampleBlock) {
      tcl_codify(NULL, input);
      return;
   }

   tcl_init();
   tcl.collectXRefs = collectXRefs;
   tcl.memberdef = memberDef;
   tcl.code = &codeOutIntf;

   if (startLine < 0) {
      startLine = 1;
   }

   tclscannerYYlineno = startLine;
   tcl.code_linenumbers = showLineNumbers;
   tcl.code_line = tclscannerYYlineno;
   tcl.code->startCodeLine(tcl.code_linenumbers);

   if (tcl.code_linenumbers) {
      tcl.code->writeLineNumber(0, 0, 0, tcl.code_line);
   }

   tcl.file_name   = "";
   tcl.this_parser = NULL;

   tcl.entry_main = tcl_entry_new();
   tcl_parse(myNs, myCls);

   tcl.code->endCodeLine();
   tcl.listScan.clear();
   tcl.ns.clear();
   tcl.cl.clear();
   tcl.fn.clear();
   tcl.entry.clear();

   printlex(tclscannerYY_flex_debug, FALSE, __FILE__, fileDef ? qPrintable(fileDef->fileName()) : "");
}

bool TclLanguageParser::needsPreprocessing(const QString &)
{
   return FALSE;
}

void TclLanguageParser::resetCodeParserState()
{
}

void TclLanguageParser::parsePrototype(const QString &text)
{
   (void)text;
}

static int yyread(char *buf, int max_size)
{
   int c = 0;

   while (tcl.input_string[tcl.input_position] != 0) {

      QString tmp1    = tcl.input_string.at(tcl.input_position);
      QByteArray tmp2 = tmp1.toUtf8();

      if (c + tmp2.length() >= max_size)  {
         // buffer is full
         break;
      }

      c += tmp2.length();     
   
      for (auto letters : tmp2) {
         *buf = letters;
          buf++;
      }

      tcl.input_position++;     
   }

   return c;
}

// to avoid a warning
void tclDummy()
{
   yy_top_state();
}

